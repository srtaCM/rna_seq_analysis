---
title: "2023oct31_deseq2"
output: html_notebook
---
# ICM 2023OCT20 DESeq2 Script

# UM v IM v H


```{r CODE CHUNK 1 SET UP}

#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install(c("circlize", "corrplot", "dendextend","readr","DESeq2","vsn", "ggfortify", "ggrepel", "ggplot2", "pheatmap", "devtools", "ggforce","pheatmap", "gplots", "RColorBrewer", "ggdendro", "magrittr","apeglm"))

setwd("~/Desktop/Lab/Working_Projects/trapseq_2023")


library(readr)
featcount <- read_table("featcount.txt", 
                        col_names = TRUE, skip = 1)
read.count <- data.frame(featcount, row.names = featcount$Geneid ) #gene ids stored as row names
geneID<- featcount$Geneid

read.count <- read.count [ ,-c(1:6)] #removes the columns without gene counts not the same as bottom row code

orig_names <- names(read.count)
#print(orig_names)

colnames(read.count) <- (c("IT-107","IT-108", "IT-109", "IT-110", "H-107", "H-108", "H-109", "H-110","H-111", "UT-106", "UT-108", "UT-114", "IT-206", "IT-207", "IT-208", "IT-209", "IM-206", "IM-207", "IM-208", "IM-209", "IM-210", "UT-204", "UT-208", "UT-213", "UT-214", "UM-204", "UM-208", "UM-213", "UM-214", "UM-215")) 
#view(read.count)


ImvHvUM <- read.count [ ,-c(1:4, 10:16,22:25)]

sample_info <- data.frame(
  sample = c( "H-107", "H-108", "H-109", "H-110","H-111","IM-206", "IM-207", "IM-208", "IM-209", "IM-210","UM-204", "UM-208", "UM-213", "UM-214", "UM-215" ),
  groups=c( "H", "H", "H", "H","H", "IM", "IM", "IM", "IM", "IM","UM","UM","UM","UM","UM"),
  condition =c("Infected","Infected","Infected","Infected","Infected","Infected","Infected","Infected","Infected","Infected", "Uninfected","Uninfected","Uninfected","Uninfected","Uninfected"),
  replicate= c("H-107", "H-108", "H-109", "H-110","H-111", "IM-206", "IM-207", "IM-208", "IM-209", "IM-210","UM-204", "UM-208", "UM-213", "UM-214", "UM-215"),
  row.names = "sample") 


metadata <- as.data.frame.array(sample_info)

all(rownames(metadata) %in% colnames(ImvHvUM))


sample_info$groups<- as.factor(sample_info$groups)
all(rownames(sample_info) %in% colnames(ImvHvUM)) #if false something is wrong
sample_info 
```


```{r CODE CHUNK 2 DATA SET MATRIX}
library(DESeq2)

dds <- DESeqDataSetFromMatrix(countData = ImvHvUM,
                              colData = sample_info,
                              design = ~condition)
print(dds)

library(magrittr)
#prefiltering
dds <- (dds[ rowSums( counts(dds) ) > 10 , ])

dds$groups<-relevel(dds$groups, ref = "UM")
dds$groups

summary(dds$groups)

```



```{r CODE CHUNK 3 VST NORMALIZATION}
#VST is offered as separate functionality which can be used for visualization, clustering or other machine learning tasks.

library(vsn)

vsd <- vst(dds, blind = TRUE )


```

#with plotpca i CAN use rld as is
```{r CODE CHUNK 4 PCA}
# PCA
library(gplots) 
library(RColorBrewer)
library(corrplot)
library(ggdendro)
library(magrittr)
library(dendextend)
library(ggplot2)
library(ggrepel)

pcadata<- plotPCA(vsd, intgroup=c("replicate","groups"), ntop=5000, returnData = TRUE) 
summary(pcadata)

percentVar <- round(100 * attr(pcadata, "percentVar"))

p <- ggplot(pcadata, aes(PC1,PC2, label = replicate, colour = groups )) +
  geom_point(size=3) 

p2 <- p + geom_text_repel(box.padding = 0.5, max.overlaps = 15, segment.linetype = 2) + labs(title = "vst transformed counts") +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance"))
p2
#ggsave("PCA_5000.png") 
#saved as of 11.26.2023



```
######Pairwise correlation cor()
#The Pearson correlation coefficient, r, is a measure of the strength of the linear relationship between two variables and is often used to assess the similarity of RNA-seq samples in a pair-wise fashion. It is defined as the covariance of two variables divided by the product of their standard deviation. 


######Hierarchical clustering
#To determine whether the different sample types can be separated in an unsupervised fashion (i.e., samples of different conditions are more dissimilar to each other than replicates within the same condition) Hierarchical clustering is typically based on pairwise comparisons of individual samples, which are grouped into “neighborhoods" of similar samples. The basis of hierarchical clustering is therefore a matrix of similarity metrics (which is different from the actual gene expression values!).
#Hierarchical clustering requires two decisions:
#  1. How should the (dis)similarity between pairs be calculated? 
#  2. How should the (dis)similarity be used for the clustering?
#A common way to assess the (dis)similarity is the Pearson correlation coefficient, r, that we just described. The corresponding distance measure is d = 1 − r. 

#Decide on how the distances should be used to define clusters of samples. The most popular choices for the linkage function are
# complete: intercluster distance ≡ largest distance between any 2 members of either cluster 
# average: intercluster distance ≡ average distance between any 2 members
# single: intercluster distance ≡ shortest distance between any 2 members

#pearson is the default, complete is best


```{r CODE CHUNK 5 DISTANCE MATRIX AND HEAT MAPS}
library(gplots) 
library(RColorBrewer)
library(corrplot)
library(ggdendro)
library(magrittr)
library(dendextend)
library(pheatmap)
library(dplyr)

#making the distance matrix
# obtain regularized log - transformed values
norm.counts <- assay(vsd)

# cor () calculates the correlation between columns of a matrix
distance.m <- as.dist (1 - cor( norm.counts , method = "pearson" ))

# plot () the output of hclust ()
hc<- hclust(distance.m)
hcd<-as.dendrogram(hc)

hcd <- hcd %>% 
  color_branches(k = 3)

plot(hcd,
     type = "rectangle", ylab = "Height",
     main = " vst transformed read counts \n distance : Pearson correlation ") 
#dev.copy2pdf(file="Distancedend.pdf")
#saved as of 11.26.2023



#Hclust HeatMap
DistMatrix <- as.matrix(distance.m)
rownames(DistMatrix) <- paste(vsd$replicate,  sep="-" )
colnames(DistMatrix)<-paste(vsd$replicate,  sep="-" )


#color scheme
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)

#generate heat map
pheatmap(DistMatrix,
         clustering_distance_rows=distance.m,
         clustering_distance_cols=distance.m,
         col=colors)
#dev.copy2pdf(file="Distancematrix.pdf")
#saved as of 11.26.2023


topVarGenes<-head(order(rowVars(assay(vsd)),decreasing=TRUE),25)
pheatmap(assay(vsd)[topVarGenes,],scale="row", cutree_cols=2, show_rownames = FALSE, main="Expression and clustering of top 25 DE genes",fontsize=11, col=colorRampPalette(rev(brewer.pal(9,"RdBu")))(255))
#dev.copy2pdf(file="25_topexpressed.pdf")
#saved as of 1.9.2024
```



```{r CODE CHUNK 6 DESEQ AND RESULTS}
library(DESeq2)


dds.ds <-DESeq(dds)
res<-results(dds.ds)
res05 <- results(dds.ds, 
                 independentFiltering = TRUE,
                 alpha = 0.05)
#still have to write it to csv


dds.ds$groups<-relevel(dds.ds$groups, ref = "UM")
dds.ds$groups
summary(res05)
table(res05$padj<0.05)
print(res05)
resultsNames(dds.ds)
```

```{r}

sum(res$pvalue < 0.05, na.rm=TRUE)

sum(!is.na(res$pvalue))

sum(res$padj < 0.05, na.rm=TRUE)

#strongest down-regulation:
resSig <- subset(res, padj < 0.05)
head(resSig[ order(resSig$log2FoldChange), ])
#... and with the strongest up-regulation:
head(resSig[ order(resSig$log2FoldChange, decreasing=TRUE), ])

diff_genes = res %>% 
  as.data.frame() %>% 
  rownames_to_column("genes") %>% 
  filter(padj < 0.05) %>% 
  arrange(desc(padj))
head(diff_genes)

```



```{r CODE CHUNK DESEQ AND RESULTS # needs fixing}
library(tibble)

results(dds.ds,tidy=TRUE) %>%
  arrange(padj) %>% 
   write_csv("de_analysis_DESeq_all.csv")

 #filter
diff_genes = res %>% 
  as.data.frame() %>%
  rownames_to_column(var="genes") %>% 
  filter(padj < 0.05) %>% 
  arrange(desc(padj)) 
write.csv("diffgenes_sig05.csv")
head(diff_genes)

```


```{r CODE CHUNK DESEQ AND  # needs fixing}
write.csv("de_analysis_DESeq_sig05.csv")
saveRDS(dds.ds, file="RobjectsDE.rds")
head(diff_genes)
#We can discover how many differential-expressed genes (at a particular p- cut-off) using the count function

results(dds.ds,tidy=TRUE) %>%
count(padj < 0.05)

```

MA plot MA plots were originally developed for microarray visualization, but they are also useful for RNA-seq analyses. The MA plot provides a global view of the relationship between the expression change between conditions (log ratios, M), the average expression strength of the genes (average mean, A) and the ability of the algorithm to detect differential gene expression: genes that pass the significance threshold (adjusted p-value) are colored in red

```{r CODE CHUNK 7 SHRINKAGE}
# no shrinkage

plotMA(res05, main = "MA Plot No shrinkage", ylim=c(-4,4))
#dev.off()

#Histograms Histograms are a simple and fast way of getting a feeling for how frequently certain values are present in a data set. A common example is a histogram of p-values
hist(res05$pvalue, 
     col = "pink", border = "black", xlab = "", ylab = "",
     main = "frequencies of p-values")
##########################################################
#shrinkage tries to help this problem: lowly expressed genes tend to have high relatively levels of variability
# LFC estimates shrunken by apeglm method
res_shrink <- lfcShrink(dds.ds, coef = "condition_Uninfected_vs_Infected", type="apeglm")
res_shrink
#pdf("res_shrink.pdf")
plotMA(res_shrink, main = "MA Plot Shrinkage", alpha=0.05, ylim=c(-4,4))
#dev.off()
```







```{r CODE CHUNK  Expression Extraction #### needs fixing}
print(res05)
library(DESeq2)
library(RColorBrewer)
library(dplyr)

results(dds.ds,tidy=TRUE) %>%
  arrange(padj) %>% 
   write_csv("de_analysis_DESeq_all.csv")
 
 #filter
 results(dds.ds,tidy=TRUE) %>%
  filter(padj < 0.05) %>% 
  write.csv("de_analysis_DESeq_sig05.csv")
saveRDS(dds.ds, file="RobjectsDE.rds")

#We can discover how many differential-expressed genes (at a particular p- cut-off) using the count function

results(dds.ds,tidy=TRUE) %>%
count(padj < 0.05)



s05<-read_csv("de_analysis_DESeq_sig05.csv")
resSig <-subset(s05, padj <0.05)
top<-head(order(resSig$padj, decreasing=TRUE),25)
pheatmap(assay(vsd)[top,],scale="row", show_rownames = TRUE,cluster_rows=TRUE,
cluster_cols=TRUE, main="Expression and clustering of top 25 DE genes at padj.05",fontsize=11, col=colorRampPalette(rev(brewer.pal(9,"RdBu")))(255))
#--> next step is enriched GO
#writing sorted to file 
#write.csv(as.data.frame(res05Ordered), file="wt_vs_mu_fdr05_fc2_results.csv")


```





```{r top25 up and down NEEDS fixing}

#down reg
#Downreg<- head(resSig[order(resSig$log2FoldChange), ])

#the strongest up-regulation:
#upreg<- head(resSig[order(resSig$log2FoldChange, decreasing =TRUE), 25 ])
```

```{r}
#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install(c("AnnotationDbi", "org.At.tair.db"))

library(AnnotationDbi)
library(org.At.tair.db)
class(org.At.tair.db)
columns(org.At.tair.db)

print(res)

res$symbol = mapIds(org.At.tair.db, 
                    keys= row.names(res), 
                    keytype= "TAIR" , 
                    column= "SYMBOL", 
                    multiVals= "first")

res$entrez = mapIds(org.At.tair.db, 
                    keys=row.names(res), 
                    keytype="TAIR", 
                    column="ENTREZID", 
                    multiVals="first")


head(res,10)
```

```{r}
resOrdered <-res[order(res$pvalue),]
head(resOrdered)
resOrderedDF <-as.data.frame(resOrdered)[1:100, ]
write.csv(resOrderedDF,file ="results.csv")
```


```{r}
#source("http://bioconductor.org/biocLite.R")
#biocLite(c("pathview","gage","gageData") )

library(pathview)
library(gageData)
data(kegg.sets.hs)
data(sigmet.idx.hs)
# Focus on signaling and metabolic pathways only
kegg.sets.hs =kegg.sets.hs[sigmet.idx.hs]
# Examine the first 3 pathways
head(kegg.sets.hs,3)

```

```{r}
diff_genes<- read_delim(file="diffgenes_sig05.csv", delim = ",")
nrow(diff_genes)

```
```{r}
diff_genes %>% 
  filter(log2FoldChange > 0) %>% 
  with(.,quantile(log2FoldChange, c(0.5,0.75,0.9)))

diff_genes %>% 
  filter(log2FoldChange > quantile(log2FoldChange, c(0.75))) %>% # keeping fold changes above the 75th percentile
  dplyr::select(genes) %>% 
  write.table(., file = "diff_genes_for_agrigo.tsv", row.names = FALSE, quote = FALSE)
```

```{r}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install(c("biomartr", "clusterProfiler","tidyverse","enrichplot","biomaRt"))
library("biomartr")
library("clusterProfiler")
library("tidyverse")
library("enrichplot")
suppressPackageStartupMessages
(library("org.At.tair.db"))
#library("biomaRt")  # only use to remove cache bug
```

```{r}
diff_genes<- read_delim(file="diffgenes_sig05.csv", delim = ",")
nrow(diff_genes)
biomartr::organismBM(organism = "Arabidopsis thaliana")
arabido_attributes = 
  biomartr::organismAttributes("Arabidopsis thaliana") %>% 
  filter(dataset == "athaliana_eg_gene")
arabido_attributes

attributes_to_retrieve = c("tair_symbol", "entrezgene_id")

result_BM <- biomartr::biomart( 
  genes  = diff_genes$genes,                  
  mart   = plants_mart,                     
  dataset  = athaliana_eg_gene,             
  attributes = attributes_to_retrieve,          
  filters =   ensembl_gene_id )
head(result_BM)  
```

```{r}
# building the universe!
all_arabidopsis_genes <- read.delim("counts.txt", header = T, stringsAsFactors = F)[,1] # directly selects the gene column

# we want the correspondence of TAIR/Ensembl symbols with NCBI Entrez gene ids
attributes_to_retrieve = c("tair_symbol", "uniprotswissprot","entrezgene_id")

# Query the Ensembl API
all_arabidopsis_genes_annotated <- biomartr::biomart(genes = all_arabidopsis_genes,
                                                     mart       = "plants_mart",                 
                                                     dataset    = "athaliana_eg_gene",           
                                                     attributes = attributes_to_retrieve,        
                                                     filters =  "ensembl_gene_id" )  

# for compatibility with enrichGO universe
# genes in the universe need to be characters and not integers (Entrez gene id)
all_arabidopsis_genes_annotated$entrezgene_id = as.character(
  all_arabidopsis_genes_annotated$entrezgene_id) 

# retrieving NCBI Entrez gene id for our genes called differential
diff_arabidopsis_genes_annotated <- biomartr::biomart(
  genes = diff_genes$genes,
  mart       = "plants_mart",                 
                                                     dataset    = "athaliana_eg_gene",           
                                                     attributes = attributes_to_retrieve,        
                                                     filters =  "ensembl_gene_id" ) 

# performing the ORA for Gene Ontology Biological Process class
ora_analysis_bp <- enrichGO(gene = diff_arabidopsis_genes_annotated$entrezgene_id, 
                            universe = all_arabidopsis_genes_annotated$entrezgene_id, 
                            OrgDb = org.At.tair.db,  # contains the TAIR/Ensembl id to GO correspondence for A. thaliana
                            keyType = "ENTREZID",
                            ont = "BP",              # either "BP", "CC" or "MF",
                            pAdjustMethod = "BH",
                            qvalueCutoff = 0.05,
                            readable = TRUE, 
                            pool = FALSE)

```

