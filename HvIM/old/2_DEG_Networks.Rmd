---
title: "2_DEG_Networking"
output: html_notebook
---

# ICM 2024FEB16 DESeq2 Script

# UM v IM v H

```{r}
#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install(c("DESeq2", readr", "AnnotationDbi", "org.At.tair.db", "pathview", "gageData", "preprocessCore", "impute", "GO.db", "WGCNA", "dynamicTreeCut", "fastcluster", "cluster", "flashClust"))
```


```{r CODE CHUNK 10 READ IN DEG DOC}
setwd("~/Desktop/Lab/Working_Projects/trapseq_2023")
library(readr)
DEGFILE<- read_delim(file="DEG_sig05.csv", delim = ",", col_names = TRUE)
nrow(DEGFILE)

deg_table <- data.frame(DEGFILE, row.names = DEGFILE$genes )#gene ids stored as row names
geneID<- DEGFILE$genes
deg_table <- deg_table[ ,-c(1:2)]
```



```{r}
library(AnnotationDbi)
suppressPackageStartupMessages(library(org.At.tair.db))
class(org.At.tair.db)
columns(org.At.tair.db)

print(deg_table)

deg_table$symbol = mapIds(org.At.tair.db, 
                    keys= row.names(deg_table), 
                    keytype= "TAIR" , 
                    column= "SYMBOL", 
                    multiVals= "first")

deg_table$entrez = mapIds(org.At.tair.db, 
                    keys=row.names(deg_table), 
                    keytype="TAIR", 
                    column="ENTREZID", 
                    multiVals="first")


head(deg_table,10)
```
```{r}
#load the WGCNA package and all of the dependencies
library(dynamicTreeCut)
library(fastcluster)
library(WGCNA)
library(cluster)
#the following setting is important, do not omit
options(stringsAsFactors = FALSE)
allowWGCNAThreads()
```


```{r}
library(readr)
featcount <- read_table("featcount.txt", 
                        col_names = TRUE, skip = 1)
read.count <- data.frame(featcount, row.names = featcount$Geneid ) #gene ids stored as row names
geneID<- featcount$Geneid

read.count <- read.count [ ,-c(1:6)] #removes the columns without gene counts 

orig_names <- names(read.count) #saving original names back up
#print(orig_names)

colnames(read.count) <- (c("IT-107","IT-108", "IT-109", "IT-110", "H-107", "H-108", "H-109", "H-110","H-111", "UT-106", "UT-108", "UT-114", "IT-206", "IT-207", "IT-208", "IT-209", "IM-206", "IM-207", "IM-208", "IM-209", "IM-210", "UT-204", "UT-208", "UT-213", "UT-214", "UM-204", "UM-208", "UM-213", "UM-214", "UM-215")) 
#view(read.count)


######              DEFINING CONDITIONS WE WANT TO WORK WITH             #################
ImvHvUM <- read.count [ ,-c(1:4, 10:16,22:25)]

sample_info <- data.frame(
  sample = c( "H-107", "H-108", "H-109", "H-110","H-111","IM-206", "IM-207", "IM-208", "IM-209", "IM-210","UM-204", "UM-208", "UM-213", "UM-214", "UM-215" ),
  groups=c( "H", "H", "H", "H","H", "IM", "IM", "IM", "IM", "IM","UM","UM","UM","UM","UM"),
  condition =c("Infected","Infected","Infected","Infected","Infected","Infected","Infected","Infected","Infected","Infected", "Uninfected","Uninfected","Uninfected","Uninfected","Uninfected"),
  replicate= c("H-107", "H-108", "H-109", "H-110","H-111", "IM-206", "IM-207", "IM-208", "IM-209", "IM-210","UM-204", "UM-208", "UM-213", "UM-214", "UM-215"),
  row.names = "sample") 


metadata <- as.data.frame.array(sample_info)

all(rownames(metadata) %in% colnames(ImvHvUM))


sample_info$groups<- as.factor(sample_info$groups)
all(rownames(sample_info) %in% colnames(ImvHvUM)) #if "false" something is wrong
sample_info 
```


```{r CODE CHUNK ??}
#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("DESeq2", force = TRUE)
library(DESeq2)


dds <- DESeqDataSetFromMatrix(countData = ImvHvUM,
                              colData = sample_info,
                              design = ~groups)
print(dds)

library(magrittr)
#prefiltering, removing genes with less than 10 counts
dds_matrix <- (dds[ rowSums( counts(dds) ) > 10 , ])

#set comparison against control/mock
dds_matrix$groups<-relevel(dds$groups, ref = "UM")
dds_matrix$groups

#summary(dds$groups)
```


```{r CODE CHUNK???}
suppressPackageStartupMessages(library(DESeq2))
library(dplyr)
library(tibble)

dds <-DESeq(dds_matrix)
datExpr0<-assay(dds)


gsg = goodSamplesGenes(datExpr0, verbose = 5);    
gsg$allOK
if (!gsg$allOK)
{
  # Optionally, print the gene and sample names that were removed:
  if (sum(!gsg$goodGenes)>0)
    printFlush(paste("Removing genes:", paste(names(datExpr)[!gsg$goodGenes], collapse = ", ")));
  if (sum(!gsg$goodSamples)>0)
    printFlush(paste("Removing samples:", paste(rownames(datExpr)[!gsg$goodSamples], collapse = ", ")));
  # Remove the offending genes and samples from the data:
  datExpr = datExpr[gsg$goodSamples, gsg$goodGenes]
}
vsd = getVarianceStabilizedData(dds)  
colnames(vsd)<- colData(dds)$Written.ID    
vsd2 <- t(vsd)    
datExpr<- vsd2
```

```{r}
library(WGCNA)
library(DESeq2)
library(cluster)
library(fastcluster)
#if (!require("BiocManager", quietly = TRUE))
#    install.packages("dynamicTreeCut")
library(dynamicTreeCut)
library(flashClust) #faster than hclust apparently
tree=flashClust(dist(vsd2), method="average")

sizeGrWindow(12,9)
par(cex = 0.6)
par(mar = c(0,4,2,0))
plot(tree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,cex.axis = 1.5, cex.main = 2)
powers = c(c(1:10), seq(from = 12, to=40, by=2))
options(stringsAsFactors = FALSE)
ALLOW_WGCNA_THREADS=20
sft = pickSoftThreshold(vsd2, dataIsExpr = TRUE, powerVector = powers, verbose = 5, networkType='signed hybrid',corFnc = "bicor", corOptions=list(maxPOutliers=0.1))
#sft = pickSoftThreshold(vsd3, dataIsExpr = TRUE, powerVector = powers, verbose = 5, networkType='signed hybrid')
```


```{r}
sizeGrWindow(9,5)
par(mfrow=c(1,2))
cex1=0.9
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
abline(h=0.90, col="red")
```


```{r}
softPower=16
adjacency=adjacency(vsd2,power=softPower, type= 'unsigned')
TOM=TOMsimilarity(adjacency, TOMType="unsigned", TOMDenom='mean')
dissTOM=1-TOM
geneTree=flashClust(as.dist(dissTOM), method="average")
sizeGrWindow(12,9)
plot(geneTree,xlab="", sub="", main="Gene clustering on TOM-based dissimilarity", labels=FALSE, hang=0.04)

minModuleSize=20
dynamicMods=cutreeDynamic(dendro=geneTree, cutHeight = "hybrid", distM=dissTOM,
                          deepSplit=2, pamRespectsDendro=FALSE, minAbsGap=0.05,
                          minClusterSize=minModuleSize)
table(dynamicMods)
dynamicColors=labels2colors(dynamicMods)
table(dynamicColors)
sizeGrWindow(8,6)
plotDendroAndColors(geneTree,dynamicColors, "Dynamic Tree Cut",
                    dendroLabels=FALSE, hang=0.03,
                    addGuide=TRUE, guideHang=0.05,
                    main= "Gene dendrogram")
```


```{r}
#vsd3=vsd2[, rank(-k, ties.method="first")<=3600]

#MEList=moduleEigengenes(vsd3, colors=dynamicColors)
#MEs = MEList$eigengenes
#MEDiss=1-cor(MEs)
#METree = flashClust(as.dist(MEDiss), method='average')
#sizeGrWindow(7,6)
#plot(METree, main="Clustering of module eigengenes", xlab='', sub='')
#MEDissThres = 0.1
#abline(h=MEDissThres, col="red")
merge=mergeCloseModules(vsd2, dynamicColors, useAbs=T, cutHeight = MEDissThres, verbose=3)
mergedColors=merge$colors
mergedMEs=merge$newMEs
sizeGrWindow(12,9)
plotDendroAndColors(geneTree, cbind(mergedColors, mergedColors),
                    c("Dynamic Tree Cut", "Merged dynamic"),
                    dendroLabels=FALSE, hang=0.03,
                    addGuide=TRUE, guideHang = 0.05)
dev.off()
moduleColors=mergedColors
colorOrder=c("grey", standardColors(50))
moduleLabels=match(moduleColors, colorOrder)-1
MEs=mergedMEs
save(MEs, moduleLabels, moduleColors, geneTree, file="intermediate.RData")
#MEList
nGenes=ncol(vsd2)
nSamples=nrow(vsd2)
MEs0=moduleEigengenes(vsd2,moduleColors)$eigengenes
MEs=orderMEs(MEs0)
```


```{r}
###signedKME
hobag=signedKME(vsd2, mergedMEs, outputColumnName="kME", corFnc="cor", corOptions= "use = 'p'")
write.table(hobag, file='hobag.csv', sep='\t')

ADJ1=abs(cor(vsd2,use="p"))^6
Alldegrees1=intramodularConnectivity(ADJ1, colorh1)
write.table(Alldegrees1, file='connectivity.csv', sep='\t')

###EXTRACT MODULES###
gene.names=colnames(vsd2)

module_colors= setdiff(unique(moduleColors), "grey")
for (color in module_colors){
  module=gene.names[which(dynamicColors==color)]
  write.table(module, paste("module_",color, ".txt",sep=""), sep="\t", row.names=FALSE, col.names=FALSE,quote=FALSE)
}
```


```{r}
###INTRAMODULAR CONNECTIVITY
datME=mergedMEs
signif(cor(datME, use="p"),2)
dissimME=(1-t(cor(datME,method='p')))/2
hclustdatME=hclust(as.dist(dissimME),method="average")
par(mfrow=c(1,1))
plot(hclustdatME, main="Clustering tree based of the module eigengenes")
sizeGrWindow(8,9)
y=(c(1,1,1,1,2,2,2,2))
plotMEpairs(datME,y)

sizeGrWindow(8,7);
which.module="pink"
ME=datME[, paste("ME",which.module, sep="")]
par(mfrow=c(2,1), mar=c(0.3, 5.5, 3, 2))
plotMat(t(scale(vsd2[,colorh1==which.module ]) ),
        nrgcols=30,rlabels=F,rcols=which.module,
        main=which.module, cex.main=2)
par(mar=c(5, 4.2, 0, 0.7))
barplot(ME, col=which.module, main="", cex.main=2,
        ylab="eigengene expression",xlab="array sample")

signif(cor(y,datME, use="p"),2)

###FROM TREE-CUTTING COMPARISON
vsd3=vsd2[, rank(-k, ties.method="first")<=3600]

dissADJ=1-ADJ1
hierADJ=hclust(as.dist(dissADJ), method="average")

###INTRAMODULAR CONNECTIVITY
ADJ1=abs(cor(vsd3,use="p"))^6        ##vsd3 = vsd2 with subset of 3600 connected genes
dissTOM=TOMdist(ADJ1)
hierTOM=hclust(as.dist(dissTOM), method="average")
colorStaticTOM = as.character(cutreeStaticColor(hierTOM, cutHeight=.99, minSize=20))
colorDynamicTOM = labels2colors (cutreeDynamic(hierTOM,method="tree"))
colorDynamicHybridTOM = labels2colors(cutreeDynamic(hierTOM, distM= dissTOM , cutHeight = 0.998,
                                                    deepSplit=2, pamRespectsDendro = FALSE))
colorh1= colorDynamicHybridTOM

Alldegrees1=intramodularConnectivity(ADJ1, colorh1)
#head(Alldegrees1)
colorlevels=unique(colorh1)
sizeGrWindow(9,6)
par(mfrow=c(2,as.integer(0.5+length(colorlevels)/2)))
par(mar = c(4,5,3,1))
for (i in c(1:length(colorlevels)))
{
  whichmodule=colorlevels[[i]];
  restrict1 = (colorh1==whichmodule);
  verboseScatterplot(Alldegrees1$kWithin[restrict1],
                     GeneSignificance[restrict1], col=colorh1[restrict1],
                     main=whichmodule,
                     xlab = "Connectivity", ylab = "Gene Significance", abline = TRUE)
}



######MODULE MEMBERSHIP -- "EIGENGENE"

modNames = substring(names(MEs), 3)
module = 'turquoise'
column = match(module, modNames);
moduleGenes=moduleColors==module;
geneModuleMembership=as.data.frame(cor(vsd3,MEs0, use='p'));
MMPvalue=as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples));
names(geneModuleMembership)=paste("MM", modNames, sep="");
names(MMPvalue)=paste("p.MM", modNames, sep="")
```


```{r}
sizeGrWindow(7,7);
par(mfrow=c(1,1));
verboseScatterplot(abs(geneModuleMembership[moduleGenes,column]),
                   abs()


#####NETWORK CONNECTIVITY GRAPHS
dissTOM = 1-TOMsimilarityFromExpr(vsd3, power = 12, TOMType= 'signed hybrid');
# Transform dissTOM with a power to make moderately strong connections more visible in the heatmap
plotTOM = dissTOM^7;
# Set diagonal to NA for a nicer plot
diag(plotTOM) = NA;
# Call the plot function
sizeGrWindow(9,9)
TOMplot(plotTOM, geneTree, mergedColors, main = "Network heatmap plot, all genes")
nSelect = 400
# For reproducibility, we set the random seed
set.seed(10);
select = sample(nGenes, size = nSelect);
selectTOM = dissTOM[select, select];
# There’s no simple way of restricting a clustering tree to a subset of genes, so we must re-cluster.
selectTree = flashClust(as.dist(selectTOM), method = "average")
selectColors = moduleColors[select];
# Open a graphical window
sizeGrWindow(9,9)
# Taking the dissimilarity to a power, say 10, makes the plot more informative by effectively changing
# the color palette; setting the diagonal to NA also improves the clarity of the plot
plotDiss = selectTOM^7;
diag(plotDiss) = NA;
TOMplot(plotDiss, selectTree, selectColors, main = "Network heatmap plot, selected genes")
MEs = moduleEigengenes(vsd2, moduleColors)$eigengenes
```


```{r CODE CHUNK????????}
powers = c(c(1:10), seq(from = 12, to=20, by=2))
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
sft = pickSoftThreshold(datExpr,corFnc = "bicor", corOptions=list(maxPOutliers=0.1),
                        networkType = "signed hybrid", powerVector = powers, verbose = 5)


softpower = 6
nethybrid = blockwiseModules(datExpr, power = softpower,maxBlockSize = 30000,
                             TOMType = "signed", minModuleSize = 30,
                             reassignThreshold = 0, mergeCutHeight = 0.25,
                             numericLabels = TRUE, pamRespectsDendro = FALSE,
                             saveTOMs = FALSE, networkType = "signed hybrid",
                             verbose = 5,corType = "bicor", maxPOutliers = 0.1,
                             pearsonFallback = "individual")
table(nethybrid$colors)

sizeGrWindow(12, 9)

mergedColors = labels2colors(nethybrid$colors)

plotDendroAndColors(nethybrid$dendrograms[[1]], mergedColors[nethybrid$blockGenes[[1]]],
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)

datME=moduleEigengenes(datExpr,nethybrid$colors)$eigengenes
signif(cor(datME, use="p"), 2)

dissimME=(1-t(cor(datME, method="p")))/2
hclustdatME=hclust(as.dist(dissimME), method="average" )
par(mfrow=c(1,1))
plot(hclustdatME, main="Clustering tree based of the module eigengenes")
sizeGrWindow(8,9)
plotMEpairs(datME)
#signif(cor(datME, ModuleEigengeneNetwork1[,-1]),2)
```


```{r CODE CHUNK ?}
sizeGrWindow(8,9)
par(mfrow=c(3,1), mar=c(1, 2, 4, 1))
which.module="turquoise";
plotMat(t(scale(datExpr[,which.module ])))
which.module="blue";
plotMat(t(scale(datExpr[,which.module ]) ),nrgcols=30,rlabels=T,
        clabels=T,rcols=which.module,
        title=which.module )
which.module="yellow";
plotMat(t(scale(datExpr[,which.module ]) ),nrgcols=30,rlabels=T,
        clabels=T,rcols=which.module,
        title=which.module )

datExpr0 = as.data.frame(t(atha[,-1]))
names(datExpr0)=atha$Geneid
rownames(datExpr0)=names(atha)[-1]
datExpr0[] = lapply(datExpr0, as.numeric)

#checking for the missing values and remotion of NA
gsg = goodSamplesGenes(datExpr0, verbose = 3);
gsg$allOK
#if it is not
if (!gsg$allOK)
{
  # Optionally, print the gene and sample names that were removed:
  if (sum(!gsg$goodGenes)>0)
    printFlush(paste("Removing genes:", paste(names(datExpr0)[!gsg$goodGenes], collapse = ", ")));
  if (sum(!gsg$goodSamples)>0)
    printFlush(paste("Removing samples:", paste(rownames(datExpr0)[!gsg$goodSamples], collapse = ", ")));
  # Remove the offending genes and samples from the data:
  datExpr0 = datExpr0[gsg$goodSamples, gsg$goodGenes]
  
  #exprSize = checkSets(datExpr0)
}

sampleTree = hclust(dist(datExpr), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
sizeGrWindow(12,9)
#pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,
     cex.axis = 1.5, cex.main = 2)
# Plot a line to show the cut
abline(h = 355, col = "red");
# Determine cluster under the line
clust = cutreeStatic(sampleTree, cutHeight = 355, minSize = 10)
table(clust)
# clust 1 contains the samples we want to keep.
keepSamples = (clust==1)
datExpr = datExpr[keepSamples, ]
nGenes = ncol(datExpr)
nSamples = nrow(datExpr)

sampleTree = hclust(dist(datExpr), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
sizeGrWindow(12,9)
#pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,
     cex.axis = 1.5, cex.main = 2)

#how to detect outliers
library(rrcov)
pcaHub = PcaHubert(datExpr)
outliers = which(pcaHub@flag =="FALSE")

# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=20, by=2))
# Call the network topology analysis function
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
# Plot the results:
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")

net = blockwiseModules(datExpr, power = 6,
                       TOMType = "unsigned", maxBlockSize = 30000, minModuleSize = 30,
                       reassignThreshold = 0, mergeCutHeight = 0.89,
                       numericLabels = TRUE, pamRespectsDendro = FALSE,
                       saveTOMs = TRUE,
                       saveTOMFileBase = "spimp_TOM",
                      verbose = 3)

table(nethybrid$colors)
# open a graphics window
sizeGrWindow(12, 9)
# Convert labels to colors for plotting
mergedColors = labels2colors(net$colors)
# Plot the dendrogram and the module colors underneath
plotDendroAndColors(net$dendrograms[[1]], mergedColors[net$blockGenes[[1]]],
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)


#module assignment
moduleLabels = nethybrid$colors
moduleColors = labels2colors(nethybrid$colors)
#module eigengene
MEs = nethybrid$MEs
geneTree = nethybrid$dendrograms[[1]]

traitData=read.csv("jh_metadata.csv")

pcapSamples = rownames(datExpr0);
traitRows = match(pcapSamples, traitData$Sample);
traitRows

datTraits = traitData[traitRows, -1];
rownames(datTraits) = traitData[traitRows, 1];
datTraits[] = lapply(datTraits, as.numeric)


# Re-cluster samples
sampleTree2 = hclust(dist(datExpr), method = "average")
# Convert traits to a color representation: white means low, red means high, grey means missing entry
traitColors = numbers2colors(datTraits, signed = FALSE);
# Plot the sample dendrogram and the colors underneath.
plotDendroAndColors(sampleTree2, traitColors,
                    groupLabels = names(datTraits),
                    main = "Sample dendrogram and trait heatmap")

names(datExpr0)


# Define numbers of genes and samples
nGenes = ncol(datExpr);
nSamples = nrow(datExpr);
# Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr, moduleColors)$eigengenes
MEs = orderMEs(MEs0)
moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);

sizeGrWindow(10,6)
# Will display correlations and their p-values
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                   signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)
par(mar = c(6, 8.5, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = names(datTraits),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = greenWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module-trait relationships"))
```


```{r CODE CHUNK?????//}
#=====================================================================================
#
#  Code chunk 4
#
#=====================================================================================


# Define variable weight containing the weight column of datTrait
iron = as.data.frame(datTraits$DPI);
names(dpi) = "Dpi"
# names (colors) of the modules
modNames = substring(names(MEs), 3)

geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"));
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples));

names(geneModuleMembership) = paste("MM", modNames, sep="");
names(MMPvalue) = paste("p.MM", modNames, sep="");

geneTraitSignificance = as.data.frame(cor(datExpr, iron, use = "p"));
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples));

names(geneTraitSignificance) = paste("GS.", names(iron), sep="");
names(GSPvalue) = paste("p.GS.", names(iron), sep="");


#=====================================================================================
#
#  Code chunk 5
#
#=====================================================================================


module = "lightcyan"
column = match(module, modNames);
moduleGenes = moduleColors==module;

sizeGrWindow(7, 7);
par(mfrow = c(1,1));
verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
                   abs(geneTraitSignificance[moduleGenes, 1]),
                   xlab = paste("Module Membership in", module, "module"),
                   ylab = "Gene significance for body weight",
                   main = paste("Module membership vs. gene significance\n"),
                   cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module, )


#=====================================================================================
#
#  Code chunk 6
#
#=====================================================================================


names(datExpr)


#=====================================================================================
#
#  Code chunk 7
#
#=====================================================================================


iron_name=names(datExpr)[moduleColors=="lightcyan"]
write(iron_name, file ="iron_names.txt", sep = "\t")

#=====================================================================================
#
#  Code chunk 8
#
#=====================================================================================


annot = read.csv(file = "GeneAnnotation.csv");
dim(annot)
names(annot)
probes = names(datExpr)
probes2annot = match(probes, annot$substanceBXH)
# The following is the number or probes without annotation:
sum(is.na(probes2annot))
# Should return 0.


#=====================================================================================
#
#  Code chunk 9
#
#=====================================================================================


# Create the starting data frame
geneInfo0 = data.frame(substanceBXH = probes,
                       geneSymbol = annot$gene_symbol[probes2annot],
                       LocusLinkID = annot$LocusLinkID[probes2annot],
                       moduleColor = moduleColors,
                       geneTraitSignificance,
                       GSPvalue)
# Order modules by their significance for weight
modOrder = order(-abs(cor(MEs, weight, use = "p")));
# Add module membership information in the chosen order
for (mod in 1:ncol(geneModuleMembership))
{
  oldNames = names(geneInfo0)
  geneInfo0 = data.frame(geneInfo0, geneModuleMembership[, modOrder[mod]], 
                         MMPvalue[, modOrder[mod]]);
  names(geneInfo0) = c(oldNames, paste("MM.", modNames[modOrder[mod]], sep=""),
                       paste("p.MM.", modNames[modOrder[mod]], sep=""))
}
# Order the genes in the geneInfo variable first by module color, then by geneTraitSignificance
geneOrder = order(geneInfo0$moduleColor, -abs(geneInfo0$GS.weight));
geneInfo = geneInfo0[geneOrder, ]




TOM = TOMsimilarityFromExpr(datExpr, power = 6);
modules = c("brown", "lightcyan");
probes = names(datExpr)
inModule = is.finite(match(moduleColors, modules));
modProbes = probes[inModule];

modTOM = TOM[inModule, inModule];
dimnames(modTOM) = list(modProbes, modProbes)
cyt = exportNetworkToCytoscape(modTOM,
                               edgeFile = paste("CytoscapeInput-edges-", paste(modules, collapse="-"), ".txt", sep=""),
                               nodeFile = paste("CytoscapeInput-nodes-", paste(modules, collapse="-"), ".txt", sep=""),
                               weighted = TRUE,
                               threshold = 0.05,
                               nodeNames = modProbes,
                               altNodeNames = modProbes,
                               nodeAttr = moduleColors[inModule]);




```


```{r}

library(pathview)
library(gageData)
data(kegg.sets.hs)
data(sigmet.idx.hs)
# Focus on signaling and metabolic pathways only
kegg.sets.hs =kegg.sets.hs[sigmet.idx.hs]
# Examine the first 3 pathways
head(kegg.sets.hs,3)

```#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install(c("biomartr", "clusterProfiler","tidyverse","enrichplot","biomaRt"))

library("biomartr")
library("clusterProfiler")
library("tidyverse")
library("enrichplot")
suppressPackageStartupMessages(library("org.At.tair.db"))
library("biomaRt")  # only use to remove cache bug

listMarts()
#ensembl=useMart(biomart, dataset = "athaliana_eg_gene")
#listDatasets(ensembl)
#listEnsemblGenomes()
#listEnsembl()nsembl_plants <- useEnsemblGenomes(biomart = "plants_mart")
searchDatasets(ensembl_plants, pattern = "Arabidopsis")
ensembl_arabidopsis <- useEnsemblGenomes(biomart = "plants_mart", 
                                         dataset = "athaliana_eg_gene")

listMarts(host="plants.ensembl.org")
mart <- useMart("plants_mart",  host = "https://plants.ensembl.org")
head(listDatasets(mart))


#ensembl = useEnsembl(biomart="plants_mart")
head(listFilters(ensembl_arabidopsis))

```#biomartr::organismBM(organism = "Arabidopsis thaliana")
#arabido_attributes = 
#  biomartr::organismAttributes("Arabidopsis thaliana") %>% 
#  filter(dataset == "athaliana_eg_gene")
#arabido_attributes

#attributes_to_retrieve = c("tair_symbol", "entrezgene_id")

#mart <- useMart("plants_mart", host = "plants.ensembl.org")
#mart <- useMart("plants_mart", "athaliana_eg_gene", host = "plants.ensembl.org")

#grep("go", listAttributes(mart)[,1], value = TRUE)


## ----filters---
filters = head(listFilters(ensembl_arabidopsis))
filters[1:5,]

## ----attributes----
attributes = listAttributes(ensembl_arabidopsis)
attributes[1:5,]
```## ----getBM1, echo=TRUE,eval=TRUE--------
affyids <- c("202763_at","209310_s_at","207500_at")
getBM(attributes = c('ensembl_gene_id', 'description'),
      filters = 'chromosome_name',
      values = affyids, 
      mart = ensembl_arabidopsis)
```


```{r}
## ----searchAttributes, echo = TRUE, eval = TRUE--------
searchAttributes(mart = ensembl_arabidopsis, pattern = "Arabidopsis")

```## ----searchFilters, echo = TRUE, eval = TRUE---------------
searchFilters(mart = ensembl_arabidopsis, pattern = "ensembl.*id")
```## ----filtervalues, fig.cap='The options available to the Chromosome/Scaffold field are limited to a pretermined list based on the values in this dataset.', echo = FALSE----
#knitr::include_graphics('filtervalues.png')

## ----chromosomeNames, results = FALSE--------------
listFilterOptions(mart = ensembl_arabidopsis, filter = "chromosome_name")

## ----listFilterOptions, results = TRUE-----
searchFilterOptions(mart = ensembl_arabidopsis, filter = "chromosome_name", 
                    pattern = "^GL")
searchFilterOptions(mart = ensembl_arabidopsis, filter = "phenotype_description", 
                    pattern = "Crohn")

## ----filterType---------------------
filterType("with_affy_hg_u133_plus_2", ensembl_arabidopsis)

## ----attributePages--------------------
pages = attributePages(ensembl_arabidopsis)
pages

## ----listAttributes--------------------
head(listAttributes(ensembl_arabidopsis, page="feature_page"))

## ----columnsAndKeyTypes-----------------
mart <- useEnsembl(dataset = "hsapiens_gene_ensembl", biomart='ensembl')
head(keytypes(mart), n = 3)
head(columns(mart), n = 3)

## ----keys1-----------------------
k = keys(mart, keytype="chromosome_name")
head(k, n=3)

## ----keys2-----------------------
k = keys(mart, keytype="chromosome_name", pattern="LRG")
head(k, n=3)

## ----select-----------------------
affy=c("202763_at","209310_s_at","207500_at")
select(mart, keys=affy, columns=c('affy_hg_u133_plus_2','entrezgene_id'),
  keytype='affy_hg_u133_plus_2')

## ----cacheInfo---------------------
biomartCacheInfo()

## ----cache-location, echo=1:2---------------
Sys.setenv(BIOMART_CACHE = tempdir())
biomartCacheInfo()
Sys.unsetenv("BIOMART_CACHE")

## ----task1, echo=TRUE,eval=TRUE----------------------
affyids=c("202763_at","209310_s_at","207500_at")
getBM(attributes = c('affy_hg_u133_plus_2', 'hgnc_symbol', 'chromosome_name',
                   'start_position', 'end_position', 'band'),
      filters = 'affy_hg_u133_plus_2', 
      values = affyids, 
      mart = ensembl)

## ----task2, echo=TRUE,eval=TRUE-------------------------
entrez=c("673","837")
goids = getBM(attributes = c('entrezgene_id', 'go_id'), 
              filters = 'entrezgene_id', 
              values = entrez, 
              mart = ensembl)
head(goids)

## ----task3, echo=TRUE,eval=TRUE----------------------
 go=c("GO:0051330","GO:0000080","GO:0000114","GO:0000082")
 chrom=c(17,20,"Y")
 getBM(attributes= "hgnc_symbol",
        filters=c("go","chromosome_name"),
        values=list(go, chrom), mart=ensembl)

## ----task4, echo=TRUE,eval=TRUE---------------------
refseqids = c("NM_005359","NM_000546")
ipro = getBM(attributes=c("refseq_mrna","interpro","interpro_description"), 
             filters="refseq_mrna",
             values=refseqids, 
             mart=ensembl)
ipro

## ----task5, eval = TRUE------------------------------
getBM(attributes = c('affy_hg_u133_plus_2','ensembl_gene_id'), 
      filters = c('chromosome_name','start','end'),
      values = list(16,1100000,1250000), 
      mart = ensembl)

## ----task6, echo=TRUE, eval = TRUE---------------------------------------------
getBM(attributes = c('entrezgene_id','hgnc_symbol'), 
      filters = 'go', 
      values = 'GO:0004707', 
      mart = ensembl)

## ----task7, eval=TRUE-------------------
entrez=c("673","7157","837")
getSequence(id = entrez, 
            type="entrezgene_id",
            seqType="coding_gene_flank",
            upstream=100, 
            mart=ensembl) 

## ----task8, echo=TRUE,eval=TRUE---------
utr5 = getSequence(chromosome=3, start=185514033, end=185535839,
                   type="entrezgene_id",
                   seqType="5utr", 
                   mart=ensembl)
utr5

## ----task9, echo=TRUE, eval=TRUE-----------
protein = getSequence(id=c(100, 5728),
                      type="entrezgene_id",
                      seqType="peptide", 
                      mart=ensembl)
protein

```


```{r}
diff_genes<- read_delim(file="diffgenes_sig05.csv", delim = ",")
nrow(diff_genes)
biomartr::organismBM(organism = "Arabidopsis thaliana")
arabido_attributes = 
  biomartr::organismAttributes("Arabidopsis thaliana") %>% 
  filter(dataset == "athaliana_eg_gene")
arabido_attributes

attributes_to_retrieve = c("tair_symbol", "entrezgene_id")

mart <- useMart("plants_mart", host = "plants.ensembl.org")
mart <- useMart("plants_mart", "athaliana_eg_gene", host = "plants.ensembl.org")
go <- getBM(attributes = c("go_id", "tair_locus", "namespace_1003"), 
            mart=ensembl)
grep("go", listAttributes(mart)[,1], value = TRUE)


result_BM <- biomartr::biomart( 
  genes  = diff_genes$genes,                  
  mart   = plants_mart,                     
  dataset  = athaliana_eg_gene,             
  attributes = attributes_to_retrieve,          
  filters =   ensembl_gene_id )
head(result_BM)  
```

```{r}
# building the universe!
all_arabidopsis_genes <- read.delim("counts.txt", header = T, stringsAsFactors = F)[,1] # directly selects the gene column

# we want the correspondence of TAIR/Ensembl symbols with NCBI Entrez gene ids
attributes_to_retrieve = c("tair_symbol", "uniprotswissprot","entrezgene_id")

# Query the Ensembl API
all_arabidopsis_genes_annotated <- biomartr::biomart(genes = all_arabidopsis_genes,
                                                     mart       = "plants_mart",                 
                                                     dataset    = "athaliana_eg_gene",           
                                                     attributes = attributes_to_retrieve,        
                                                     filters =  "ensembl_gene_id" )  

# for compatibility with enrichGO universe
# genes in the universe need to be characters and not integers (Entrez gene id)
all_arabidopsis_genes_annotated$entrezgene_id = as.character(
  all_arabidopsis_genes_annotated$entrezgene_id) 

# retrieving NCBI Entrez gene id for our genes called differential
diff_arabidopsis_genes_annotated <- biomartr::biomart(
  genes = diff_genes$genes,
  mart       = "plants_mart",                 
                                                     dataset    = "athaliana_eg_gene",           
                                                     attributes = attributes_to_retrieve,        
                                                     filters =  "ensembl_gene_id" ) 

# performing the ORA for Gene Ontology Biological Process class
ora_analysis_bp <- enrichGO(gene = diff_arabidopsis_genes_annotated$entrezgene_id, 
                            universe = all_arabidopsis_genes_annotated$entrezgene_id, 
                            OrgDb = org.At.tair.db,  # contains the TAIR/Ensembl id to GO correspondence for A. thaliana
                            keyType = "ENTREZID",
                            ont = "BP",              # either "BP", "CC" or "MF",
                            pAdjustMethod = "BH",
                            qvalueCutoff = 0.05,
                            readable = TRUE, 
                            pool = FALSE)

```

``````{r}
# universe
universe<- read_delim(file="downreg2500.tsv", delim = ",")
universe<-universe$Row.names

# load  annotation and ID library
library(AnnotationDbi)
library(org.At.tair.db)
class(org.At.tair.db)
columns(org.At.tair.db)

#print(res05)

res05$symbol = mapIds(org.At.tair.db, 
                    keys= row.names(res05), 
                    keytype= "TAIR" , 
                    column= "SYMBOL", 
                    multiVals= "first")

res05$entrez = mapIds(org.At.tair.db, 
                    keys=row.names(res05), 
                    keytype="TAIR", 
                    column="ENTREZID", 
                    multiVals="first")

# convert gene names to Entrez ID
genemap <- select(AnnotationDb, selected, "ENTREZID", "SYMBOL")
univmap <- select(org.At.tair.db, universe, "ENTREZID", "SYMBOL")

# load GO scoring package
biocLite(“GOstats”)
library(GOstats)
# set up analysis
param<- new ("GOHyperGParams", geneIds = genemap, universeGeneIds=univmap, annotation="org.Mm.eg.db",
ontology="BP",pvalueCutoff=0.01, conditional=FALSE, testDirection="over")
# run analysis
hyp<-hyperGTest(param)
# visualize
summary(hyp)
## Select/sort on Pvalue, Count, etc.
```

