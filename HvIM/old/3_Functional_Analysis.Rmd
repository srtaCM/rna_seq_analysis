---
title: "3_Functional_Analysis"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

```{r}
### INSTALLING PACKAGES ###
#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install(c("readr", "enrichplot", "DOSE", "clusterProfiler", "AnnotationHub", "ensembldb", "tidyverse", "AnnotationDbi", "org.At.tair.db", "pathview", "gageData", "ggupset", "GOCompare", "UpSetR"))

###Loading Library
suppressPackageStartupMessages(library("org.At.tair.db"))
library(enrichplot)
suppressPackageStartupMessages(library(DOSE)) #for human? Disease Ontology Semantic and Enrichment analysis
suppressPackageStartupMessages(library(pathview)) #calls specific pathway
library(clusterProfiler) #prettydoc
library(AnnotationHub)
library(ensembldb)
library(tidyverse)
library(readr)
library(ggupset)
devtools::install_github("YuLab-SMU/clusterProfiler")
```

```{r}
# Setting up environment ===================================================
setwd("~/Desktop/Lab/Working_Projects/trapseq_2023")
# Clean environment
rm(list = ls(all.names = TRUE)) # will clear all objects including hidden objects
gc() # free up memory and report the memory usage
options(max.print = .Machine$integer.max, scipen = 999, stringsAsFactors = F, dplyr.summarise.inform = F) # avoid truncated output in R console and scientific notation


# Loading relevant libraries 
library(tidyverse) # includes ggplot2, for data visualisation. dplyr, for data manipulation.
library(RColorBrewer) # for a colourful plot
library(pheatmap)
library(org.At.tair.db) # for analysis
library(DOSE)
library(enrichplot) # for visualisations
library(ggupset) # for visualisations

# Functions ------------------------------------------------
## Function: Adjacency matrix to list ####
matrix_to_list <- function(pws){
  pws.l <- list()
  for (pw in colnames(pws)) {
    pws.l[[pw]] <- rownames(pws)[as.logical(pws[, pw])]
  }
  return(pws.l)
}
```


```{r}
# Read in data ===================================================

df <- read.csv(paste0(file = "de_analysis_DESeq_sig01.csv"), row.names = 1)

# Annotate according to differential expression
df <- df %>% mutate(diffexpressed = case_when(
  log2FoldChange > 0 & padj < 0.05 ~ 'UP',
  log2FoldChange < 0 & padj < 0.05 ~ 'DOWN',
  padj > 0.05 ~ 'NO'
))
```

```{r}
# Get the genes that are present in your dataframe
genes_in_data <- df$symbol

# Read in the .gmt file
file <- "KEGG.db_1.0.tar.gz"
pwl2 <- read.gmt(file) 
# Subset to the genes that are present in our dataset
pwl2 <- pwl2[pwl2$gene %in% genes_in_data,] 
# Save the filtered background gene set
filename <- 'kegg.RDS'
saveRDS(pwl2, filename)

            
# SQUIDTIP! If you want to parse several .gmt files at once, you can use a loop:
#gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
#for (file in gmt_files){
#	file <- gmt_files[1]
#        pwl2 <- read.gmt(file) 
#	pwl2 <- pwl2[pwl2$gene %in% genes_in_data,]
#        filename <- paste(gsub('c.\\.', '', gsub('.v7.5.*$', '', file)), #'.RDS', sep = '')
#	saveRDS(pwl2, filename)
#}
```


```{r}
## Prepare deg results -----------------------------------------------

# If you forgot to do that before, annotate according to differential expression
df <- df %>% mutate(diffexpressed = case_when(
  log2FoldChange > 0 & padj < 0.01 ~ 'UP',
  log2FoldChange < 0 & padj < 0.01 ~ 'DOWN',
  padj > 0.01 ~ 'NO'
  
))

# Remove non-significant genes
df <- df[df$diffexpressed != 'NO', ]

# Substitute names so they are annotated nicely in the heatmap later
unique(df$diffexpressed)

# Split the dataframe into a list of sub-dataframes: upregulated, downregulated genes
deg_results_list <- split(df, df$diffexpressed)
```



```{r}
## Run ClusterProfiler -----------------------------------------------

# Settings
name_of_comparison <- 'upvdown' # for our filename
background_genes <- 'ont' # for our filename
bg_genes <- readRDS(paste0(bg_path, 'ont.RDS')) # read in the background genes
padj_cutoff <- 0.05 # p-adjusted threshold, used to filter out pathways
genecount_cutoff <- 5 # minimum number of genes in the pathway, used to filter out pathways
filename <- paste0(out_path, 'clusterProfiler/', name_of_comparison, '_', background_genes) # filename of our PEA results
```

```{r}
# SQUIDTIP! An option to read in your background genes by only defining your 'background_genes' variable
if(background_genes == 'KEGG'){
  bg_genes <- readRDS(paste0(bg_path, 'kegg.RDS'))
} else if(background_genes == 'reactome'){
  bg_genes <- readRDS(paste0(bg_path, 'reactome.RDS'))
} else if(background_genes == 'go.bp'){
  bg_genes <- readRDS(paste0(bg_path, 'go.bp.RDS'))
} else {
  stop('Invalid background genes. Select one of the following: KEGG, Reactome, GO, or add new pwl to function')
  # Run clusterProfiler on each sub-dataframe
res <- lapply(names(deg_results_list),
                 function(x) enricher(gene = deg_results_list[[x]]$gene_symbol,
                                      TERM2GENE = bg_genes))
names(res) <- names(deg_results_list)

#Convert the list of enrichResults for each sample_pattern to a dataframe with the pathways
res_df <- lapply(names(res), function(x) rbind(res[[x]]@result))
names(res_df) <- names(res)
res_df <- do.call(rbind, res_df)
head(res_df)
#Convert the enrichResults to a dataframe with the pathways
res_df <- lapply(names(res), function(x) rbind(res[[x]]@result))
names(res_df) <- names(res)
res_df <- do.call(rbind, res_df)
head(res_df)
res_df <- res_df %>% mutate(minuslog10padj = -log10(p.adjust),
                                  diffexpressed = gsub('\\.GOBP.*$|\\.KEGG.*$|\\.REACTOME.*$', '', rownames(res_df)))

# Subset to those pathways that have p adj < cutoff and gene count > cutoff (you can also do this in the enricher function)
target_pws <- unique(res_df$ID[res_df$p.adjust < padj_cutoff & res_df$Count > genecount_cutoff]) # select only target pathways have p adjusted < 0.05 and at least 6 genes
res_df <- res_df[res_df$ID %in% target_pws, ]
print('Saving clusterprofiler results')
write.csv(res_df, paste0(filename, '_resclusterp.csv'), row.names = FALSE)
}
```


```{r}
library(AnnotationDbi)
library(org.At.tair.db)
class(org.At.tair.db)
columns(org.At.tair.db)

###these are all differentially expressed genes that have been filtered by padj .01 
ALL_DEG<- read.csv(file = "de_analysis_DESeq_sig01.csv")
ALL_DEG <- data.frame(ALL_DEG, row.names = ALL_DEG$X )#gene ids stored as row names
#nrow(ALL_DEG) #show total rows
geneID<- ALL_DEG$X #save gene names separately 

###add information to table
ALL_DEG$symbol = mapIds(org.At.tair.db, 
                    keys= row.names(ALL_DEG), 
                    keytype= "TAIR" , 
                    column= "SYMBOL", 
                    multiVals= "first")

ALL_DEG$entrez = mapIds(org.At.tair.db, 
                    keys=row.names(ALL_DEG), 
                    keytype="TAIR", 
                    column="ENTREZID", 
                    multiVals="first")

df <- ALL_DEG %>% mutate(diffexpressed = case_when(
  log2FoldChange > 1 & padj < 0.01 ~ 'UP',
  log2FoldChange < 1 & padj < 0.01 ~ 'DOWN',
  padj > 0.01 ~ 'NO'
))


###cleaning up table: remove columns, add column names, remove all genes with na values, and duplicate genes
ALL_DEG_tb <- df[ ,-c(1)]  %>%
  data.frame()  %>% 
  rownames_to_column(var="gene") %>%
  as_tibble() %>% 
  na.omit() %>% 
  distinct(symbol, .keep_all = TRUE) %>% 
  arrange(desc(log2FoldChange))


allOE_genes <- ALL_DEG_tb$entrez
```


```{r}
library(readr)
IMdwn<- read_table("dwnLFC1_01_IM.csv", col_names = TRUE) 
IMup<- read_table("upLFC1_01_IM.csv",  col_names = TRUE)
Hdwn<- read_table("downLFC1_0.01_H.csv", col_names = TRUE)
Hup<- read_table( "upLFC1_0.01_H.csv", col_names = TRUE)
```



```{r}
####      DOWNREGULATED INFECTED MESOPHYLL CELLS

IMdwn <- data.frame(IMdwn, row.names = IMdwn$Row.names )#gene ids stored as row names
#nrow(ALL_DEG) #show total rows
geneID1<- IMdwn$Row.names #save gene names separately 
colnames(IMdwn)

###add information to table
IMdwn$symbol = mapIds(org.At.tair.db, 
                    keys= row.names(IMdwn), 
                    keytype= "TAIR" , 
                    column= "SYMBOL", 
                    multiVals= "first")

IMdwn$entrez = mapIds(org.At.tair.db, 
                    keys=row.names(IMdwn), 
                    keytype="TAIR", 
                    column="ENTREZID", 
                    multiVals="first")

###cleaning up table: remove columns, add column names, remove all genes with na values, and duplicate genes
IMdwn_tb <- IMdwn[ ,-c(1,4:5)]  %>% 
  data.frame()  %>% 
  rownames_to_column(var="gene") %>%
  as_tibble() %>% 
  na.omit() %>% 
  distinct(symbol, .keep_all = TRUE) %>%  
  arrange(desc(UMVsIM_log2FoldChange))

dwnIM<- IMdwn_tb$entrez
```


```{r}
#####         OVER REPRESENTED ANALYSIS
###Run GO enrichment analysis, xOne of "BP", "MF", and "CC" subontologies, or "ALL" for all three.

###shiny Go says no enrichment found for BP
eGO_dwnIM <- enrichGO(gene = dwnIM,
                universe = allOE_genes,
                keyType = "ENTREZID",
                OrgDb = org.At.tair.db,
                ont = "BP",
                pAdjustMethod = "BH",
                qvalueCutoff = 0.01,
                readable = TRUE)
barplot(eGO_dwnIM)
dotplot(eGO_dwnIM, showCategory=10, color = "p.adjust") + ggtitle("Dotplot for ORA")


### Output results from GO analysis to a table
#cluster_summary <- data.frame(eGO_dwnIM)
#write.csv(cluster_summary, "eGO_dwnIMclusterProfiler_oe.csv")
```


```{r not working and in progress }
#GENE SET ENRICHMENT ANALYSIS
kegg_gene_list = sort(dwnIM,decreasing = TRUE)
#view(kegg_gene_list)
library(KEGGREST)


kocu <- keggLink("pathway", "ath") %>% 
  tibble(pathway = ., eg = sub("ath:", "", names(.)))
#view(kocu)
ath_kegg_anno <- kocu %>%
    mutate(
        symbol = mapIds(org.At.tair.db, eg, "SYMBOL", "TAIR"),
        ensembl = mapIds(org.At.tair.db, eg, "ENTREZID", "TAIR"))
#print(ath_kegg_anno)

ath_pathways <- keggList("pathway", "ath") %>% 
    tibble(pathway = names(.), description = .)

```


```{r}
#####       UP REGULATED INFECTED MESOPHYLL CELLS

IMup <- data.frame(IMup, row.names = IMup$Row.names ) #gene ids stored as row names

###add information to table
IMup$symbol = mapIds(org.At.tair.db, 
                    keys= row.names(IMup), 
                    keytype= "TAIR" , 
                    column= "SYMBOL", 
                    multiVals= "first")

IMup$entrez = mapIds(org.At.tair.db, 
                    keys=row.names(IMup), 
                    keytype="TAIR", 
                    column="ENTREZID", 
                    multiVals="first")


###cleaning up table: remove columns, add column names, remove all genes with na values, and duplicate genes
IMup_tb <- IMup[ ,-c(1,4:5)]  %>%
  data.frame()  %>% 
  rownames_to_column(var="gene") %>%
  as_tibble() %>% 
  na.omit() %>% 
  distinct(symbol, .keep_all = TRUE) %>% 
  arrange(desc(UMVsIM_log2FoldChange))

upIM<- IMup_tb$entrez
```


```{r}
####            OVER REPRESENTED ANALYSIS
### Run GO enrichment analysis:"BP", "MF", and "CC" sub-ontologies, or "ALL" for all three.
eGO_upIM <- enrichGO(gene = upIM,
                universe = allOE_genes,
                keyType = "ENTREZID",
                OrgDb = org.At.tair.db,
                ont = "ALL",
                pAdjustMethod = "BH",
                qvalueCutoff = 0.01,
                readable = TRUE)

barplot(eGO_upIM)
dotplot(eGO_upIM, showCategory=10, color = "p.adjust") + ggtitle("Dotplot for ORA") 
#upsetplot(eGO_upIM) 

### Output results from GO analysis to a table
#cluster_summary <- data.frame(eGO_upIM)
#write.csv(cluster_summary, "eGO_upIMclusterProfiler_oe.csv")

```


```{r NOT WORKING AND IN PROGRESS 2}
#####           DOWNREGULATED HAUSTORIATED CELLS
Hdwn <- data.frame(Hdwn, row.names = Hdwn$Row.names )#gene ids stored as row names
#nrow(ALL_DEG) #show total rows

str(Hdwn)
print(Hdwn$Row.names)
sum(is.na(Hdwn$Row.names))
keys_subset <- head(Hdwn$Row.names, 10)
keys <- Hdwn$Row.names
#print(keys_subset)

#add information to table
Hdwn$symbol = mapIds(org.At.tair.db, 
                    keys= keys, 
                    keytype= "TAIR" , 
                    column= "SYMBOL", 
                    multiVals= "first")

Hdwn$entrez = mapIds(org.At.tair.db, 
                    keys=keys, 
                    keytype="TAIR", 
                    column="ENTREZID", 
                    multiVals="first")


#cleaning up table: remove columns, add column names, remove all genes with na values, and duplicate genes
Hdwn_tb <- Hdwn[ ,-c(1:3)]  %>%
data.frame()  %>% rownames_to_column(var="gene") %>%
as_tibble() %>% na.omit() %>% distinct(symbol, .keep_all = TRUE) %>% 
  arrange(desc(UMVsH_log2FoldChange))



dwn_H<- Hdwn_tb$entrez
#It looks like the ego_ALLdwnH object does not contain any enriched terms, as indicated by the message "0 enriched terms found." This could be due to several reasons, such as the gene set you provided (dwn_H) not being significantly enriched for any Gene Ontology (GO) terms based on the statistical criteria you set (e.g., p-adjusted < 0.05).



ego_ALLdwnH <- enrichGO(gene = dwn_H,
                universe = allOE_genes,
                keyType = "ENTREZID",
                OrgDb = org.At.tair.db,
                ont = "ALL",
                pAdjustMethod = "BH",
                readable = TRUE,
               # qvalueCutoff = 0.01,
                pvalueCutoff = 1,
                qvalueCutoff = 1
               )
print(ego_ALLdwnH)

#barplot(ego_ALLdwnH)
#dotplot(ego_ALLdwnH, showCategory=10, color = "p.adjust") + ggtitle("Dotplot for ORA") 
#upsetplot(ego_ALLupIMH)
## Output results from GO analysis to a table
#cluster_summary <- data.frame(ego_ALL)
#write.csv(cluster_summary, "clusterProfiler_oe.csv")

#dotplot(ego_ALL, showCategory=10, color = "p.adjust") + ggtitle("Dotplot for ORA") 
```


```{r}
#####             UPREGULATED HAUSTORIATED CELLS
Hup <- data.frame(Hup, row.names = Hup$Row.names )#gene ids stored as row names

###adding information to table
Hup$symbol = mapIds(org.At.tair.db, 
                    keys= row.names(Hup), 
                    keytype= "TAIR" , 
                    column= "SYMBOL", 
                    multiVals= "first")

Hup$entrez = mapIds(org.At.tair.db, 
                    keys=row.names(Hup), 
                    keytype="TAIR", 
                    column="ENTREZID", 
                    multiVals="first")

###cleaning up table: remove columns, add column names, remove all genes with na values, and duplicate genes
Hup_tb <- Hup[ ,-c(1:3)]  %>%
  data.frame()  %>% 
  rownames_to_column(var="gene") %>%
  as_tibble() %>% na.omit() %>% 
  distinct(symbol, .keep_all = TRUE) %>% 
  arrange(desc(UMVsH_log2FoldChange))

upH = Hup_tb$entrez
```


```{r}
#####               OVER REPRESENTED ANALYSIS
### Run GO enrichment analysis:"BP", "MF", and "CC" sub-ontologies, or "ALL" for all three.
eGO_upH <- enrichGO(gene = upH,
                universe = allOE_genes,
                keyType = "ENTREZID",
                OrgDb = org.At.tair.db,
                ont = "ALL",
                pAdjustMethod = "BH",
                qvalueCutoff = 0.01,
                readable = TRUE)
barplot(eGO_upH)
dotplot(eGO_upH, showCategory=10, color = "p.adjust") + ggtitle("Dotplot for ORA") 
#upsetplot(eGO_upH)

### Output results from GO analysis to a table
#cluster_summary <- data.frame(eGO_upH)
#write.csv(cluster_summary, "eGO_upHclusterProfiler_oe.csv")

```



```{r}
## background set of ensgenes
library(org.At.tair.db)

allOE_genes <- ALL_DEG_tb$entrez


#sigOE0.01 = dplyr::filter(ALL_DEG_tb, padj < 0.01)
#sigOE_01genes = sigOE0.01$entrez 
#nrow(sigOE0.01)
#sigOE0.05 = dplyr::filter(ALL_DEG_tb, padj < 0.05)
#sigOE_05genes = sigOE0.05$entrez

```

```{r}
library(VennDiagram)
#install.packages("ggvenn")
# Find common GO terms (similar terms)
library(ggvenn)
 

# Create a list of sets for the Venn diagram
venn_list <- list(
  dwnIM = eGO_dwnIM$Description,
  upH = eGO_upH$Description
)

# Create the Venn diagram
ggvenn(venn_list, "testvenn.tiff")


```


```{r}
library(clusterProfiler)

# Visualize GO enrichment results
ggplot(ego_ALLdwnIM, aes(x = Count, y = Description, fill = Count)) +
  geom_point()
ggplot(ego_ALLupIM, aes(x = Count, y = Description, fill = Count)) +
  geom_point()


```




```{r}
gene.df <- bitr(ego_ALLdwnIM, fromType = "ENTREZID",
        toType = c( "GENENAME","SYMBOL"),
        OrgDb = org.At.tair.db)

ego3 <- gseGO(geneList     = IMup_tb,
              OrgDb        = org.At.tair.db,
              ont          = "CC",
              minGSSize    = 100,
              maxGSSize    = 500,
              pvalueCutoff = 0.05,
              verbose      = FALSE)
```

```{r}
library(ggplot2)
library(dplyr)
library(stringr)
x<-gseDO(sigOE_genes)
## count the gene number
gene_count<- x@result %>% group_by(ID) %>% summarise(count = sum(str_count(core_enrichment, "/")) + 1)

## merge with the original dataframe
dot_df<- left_join(x@result, gene_count, by = "ID") %>% mutate(GeneRatio = count/setSize)

## plot
library(forcats) ## for reordering the factor
ggplot(dot_df, aes(x = GeneRatio, y = fct_reorder(Description, GeneRatio))) + 
               geom_point(aes(size = GeneRatio, color = p.adjust)) +
               theme_bw(base_size = 14) +
        scale_colour_gradient(limits=c(0, 0.10), low="red") +
        ylab(NULL) +
        ggtitle("GO pathway enrichment")
dot_df = dot_df[1:50,] ## small dataset
dot_df$type = "upregulated"
dot_df$type[dot_df$NES < 0] = "downregulated"

## from Tommy's code
p <- ggplot(dot_df, aes(x = GeneRatio, y = fct_reorder(Description, GeneRatio))) + 
               geom_point(aes(size = GeneRatio, color = p.adjust)) +
               theme_bw(base_size = 14) +
        scale_colour_gradient(limits=c(0, 0.10), low="red") +
        ylab(NULL) +
        ggtitle("GO pathway enrichment")

p + facet_grid(.~type)
```

```{r}
#enrich go plot
#pairwise termsim gets the similarity matrix, method of calculating the similarity between nodes, one of "Resnik", "Lin", "Rel", "Jiang" , "Wang" and "JC"(Jaccard similarity coefficient) methods
pwt <- pairwise_termsim(ego_ALL,
                        method = "JC",
                        semData = NULL,
                        showCategory = 50)
emapplot(pwt, showCategory = 10, color = "qvalue")
p1 <- treeplot(pwt,) #The default agglomeration method in treeplot() is ward.D
p2 <- treeplot(pwt, hclust_method = "average")
aplot::plot_list(p1, p2, tag_levels='A')

#Enrichment map organises enriched terms into a network with edges weighted by the ratio of overlapping gene sets. Mutually overlapping gene sets are tending to cluster together, making it easy to identify functional modules.

p2 <- emapplot(pwt, showCategory = 10, cex_category=1.5)
p3 <- emapplot(pwt, showCategory = 10,layout="kk")
p4 <- emapplot(pwt, showCategory = 10, cex_category=1.5, layout="kk") 
cowplot::plot_grid( p2, p3, p4, ncol=2, labels=LETTERS[1:4])


```

```{r}
library(DOSE)
## To color genes by log2 fold changes, we need to extract the log2 fold changes 
OE_foldchanges <- sigOE$log2FoldChange
names(OE_foldchanges) <- sigOE$gene

## Cnetplot details the genes associated with one or more terms
cnetplot(ego_ALL,
         categorySize="pvalue",
         showCategory = 5,
         foldChange=OE_foldchanges,
         vertex.label.font=6)


OE_foldchanges <- ifelse(OE_foldchanges > 1, 1, OE_foldchanges)
OE_foldchanges <- ifelse(OE_foldchanges < -1, -1, OE_foldchanges)
cnetplot(ego_ALL,
         categorySize="pvalue",
         showCategory = 5,
         foldChange=OE_foldchanges,
         vertex.label.font=6)
heatplot(ego_ALL, showCategory = 5) #relationship between selected genes and corresponding biological concepts.
```

```{r}
## Subsetting the ego results without overwriting original `ego` variable
ego2 <- ego_ALL
ego2@result <- ego_ALL@result[c(1,3,4,8,9),]
## Plotting terms of interest
cnetplot(ego2,
         categorySize="pvalue",
         foldChange=OE_foldchanges,
         showCategory = 5,
         vertex.label.font=6)

```

```{r}
search_kegg_organism('ath', by='kegg_code')
search_kegg_organism('Arabidopsis thaliana', by='scientific_name')

# omit any NA values 
kegg_gene_list<-na.omit(sigOE_genes)

# sort the list in decreasing order (required for clusterProfiler)
kegg_gene_list = sort(kegg_gene_list, decreasing = TRUE)


ora_analysis_kegg <- enrichKEGG(gene = kegg_gene_list,
                                universe =allOE_genes,
                                organism = "ath",
                                keyType = "ncbi-geneid",
                                minGSSize = 10,
                                maxGSSize = 500,
                                pAdjustMethod = "BH",
                                qvalueCutoff = 0.01,
                                use_internal_data = FALSE) # force to query latest KEGG db
head(ora_analysis_kegg)

ora_analysis_kegg_modules <- enrichMKEGG(gene = kegg_gene_list,
                                         universe =allOE_genes,
                                         organism = "ath",
                                         keyType = "ncbi-geneid",
                                         minGSSize = 10,           # minimal size of genes annotated by Ontology term for testing.
                                         maxGSSize = 500,          # maximal size of genes annotated for testing
                                         pAdjustMethod = "BH",
                                         qvalueCutoff = 0.01)
ggplot(ora_analysis_kegg)
#browseKEGG(ora_analysis_kegg, 'ath00195')
library("pathview")
#ath04145 <- pathview(gene.data  = allOE_genes, pathway.id = "ath00195", species    = "ath")

# create a simple dotplot graph
dotplot(ora_analysis_kegg, 
    color = "qvalue", 
    showCategory = 5, 
    size = "Count")


ridgeplot(ora_analysis_kegg, showCategory = 30) + labs(title = "KEGG_Pathway Analysis", x = "enrichment distribution") + scale_fill_gradient(low = "#56B1F7", high = "#132B43")

```
```{r}
library(KEGGREST)
pathways <- keggList("pathway")
head(pathways)

library(pathview)
map <- gsub("ath04814", "", names(pathways)[2])  # remove 'path:'
pv.out <- pathview(gene.data = sigOE_genes, cpd.data = allOE_genes, gene.idtype = "KEGG", 
    pathway.id = map, species = "ath", out.suffix = map, keys.align = "y", 
    kegg.native = T, match.data = T, key.pos = "topright")
plot.name <- paste(map, map, "png", sep = ".")
```

