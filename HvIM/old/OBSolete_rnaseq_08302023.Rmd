---
title: "DESeq_rna2_13_2023"
output: html_ntb.rmd
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

```{r}
library(magrittr)  #this will allow us to string commands together in a UNIX-pipe-like fashion using %>%

read.counts <- read.table ("~/Desktop/Lab/Coding/featurecount.readcount.txt.gz", header = TRUE)

row.names(read.counts) <- read.counts$Geneid #gene ids will be stored as row names
read.counts <- read.counts [ ,-c(1:6)] #removes columns without gene counts

#giving the columns names
orig_names <- names (read.counts) 
names(read.counts) <- c("IM1", "IM2", "IM3", "IM4", "IM5", "IT1", "IT2", "IT3", "IT4", "IT5", "UM1", "UM2", "UM3", "UM4", "UM5", "UT1", "UT2", "UT3", "UT4")
str(read.counts)
head(read.counts)

#make a data frame, row names should match sample names
sample_info <- data.frame(condition = gsub ( "_[0 -9]+ " , " " , names (read.counts)),
    row.names = names(read.counts))
```

```{r}
#for installing the program if necessary

#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install(c("DESeq2"))

```


```{r}
#sample names
sample_info<- data.frame(condition=gsub("_[0 -9]+", " ", names(read.counts)),
                         row.names=names(read.counts))
```

```{r}
#BiocManager::install(c("DESeq2"))
library(DESeq2)
library(S4Vectors)
library(stats4)
library(BiocGenerics)
DESeq.ds <- DESeqDataSetFromMatrix(countData = read.counts,
                                   colData = sample_info,
                                   design = ~condition)
####Check results 
colData (DESeq.ds) %>% head
assay (DESeq.ds) %>% head
rowRanges (DESeq.ds) %>% head
```


```{r}
#In order to compare the gene expression between two conditions, we must therefore calculate the fraction of the reads assigned to each gene relative to the total number of reads and with respect to the entire RNA repertoire which may vary drastically from sample to sample. While the number of sequenced reads is known, the total RNA library and its complexity is unknown and variation between samples may be due to contamination as well as biological reasons. 

#The purpose of normalization is to eliminate systematic effects that are not associated with the biological differences of interest. 

#test what counts() returns
#counts (DESeq.ds) %>% str

# remove genes without any counts
DESeq.ds <- DESeq.ds[rowSums(counts(DESeq.ds)) > 0, ]

# investigate different library sizes
colSums(counts(DESeq.ds)) # should be the same as colSums (read.counts)

#calculate the size factor and add it to the data set
DESeq.ds <-estimateSizeFactors(DESeq.ds)
sizeFactors(DESeq.ds)

# counts () allows you to immediately retrieve the _ normalized _ read counts
counts.sf_normalized <- counts(DESeq.ds, normalized = TRUE)
```

```{r}
# transform size - factor normalized read counts to log2 scale using a pseudocount of 1
log.norm.counts <- log2(counts.sf_normalized + 1)

par(mfrow=c(2,1)) # to plot the following two images underneath each other

# first, boxplots of non - transformed read counts (one per sample )
boxplot(counts.sf_normalized, notch = TRUE,
        main = "untransformed read counts", ylab = "read counts" )

# box plots of log2 - transformed read counts
boxplot(log.norm.counts, notch = TRUE,
        main = "log2-transformed read counts",
        ylab = "log2 (read counts)")
```

```{r}
plot(log.norm.counts[,1:2], cex =.1 , main = "Normalized log2(read counts)")
```

```{r}
#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install()
#IF NEEDED , install the vsn package
#BiocManager::install(c("vsn"))

```

```{r}
library(vsn)
library(ggplot2)
msd_plot<-meanSdPlot(log.norm.counts,
                     ranks = FALSE, # show the data on the original scale
                     plot = FALSE)
msd_plot$gg +
  ggtitle("sequencing depth normalized log2 (read counts)") +
  ylab("standard deviation")
```


```{r}
#obtain regularized log-transformed values
DESeq.rlog<-rlog(DESeq.ds, blind = TRUE )
rlog.norm.counts <- assay(DESeq.rlog)

# mean -sd plot for rlog - transformed data
library(vsn)
library(ggplot2)
msd_plot <- meanSdPlot(rlog.norm.counts,
                       ranks = FALSE , # show the data on the original scale
                       plot = FALSE )
msd_plot$gg +
  ggtitle("rlog-transformed read counts") +
  ylab("standard deviation")
```


```{r}
# cor () calculates the correlation between columns of a matrix
distance.m_rlog <- as.dist(1-cor(rlog.norm.counts, method = "pearson") )

# dendrogram plot () can directly interpret the output of hclust ()
plot ( hclust (distance.m_rlog),
       labels = colnames(rlog.norm.counts),
       main = "rlog transformed read counts\ndistance : Pearson correlation")
```


```{r}
#principle component analysis
pc <- prcomp(t(rlog.norm.counts))
plot(pc$x[,1], pc$x[,2],
     col = colData(DESeq.ds) [,1],
     main = "PCA of seq.depth normalized\n and rlog-transformed read counts")
```


```{r}
library(DESeq2)
library(ggplot2)

 # PCA
P <-plotPCA(DESeq.rlog)

# plot cosmetics
P <- P + theme_bw() + ggtitle("Rlog transformed counts")
print(P)
```



```{r}
# DESeq uses the levels of the condition to determine the order of the comparison
str(colData(DESeq.ds)$condition)

# set WT as the first -level - factor
colData(DESeq.ds)$condition <- relevel(colData(DESeq.ds)$condition, "IM1")
DESeq.ds<-DESeq(DESeq.ds)
```


```{r}
DESeq.ds <- estimateSizeFactors(DESeq.ds) # sequencing depth normalization between the samples
DESeq.ds <- estimateDispersions(DESeq.ds) # gene - wise dispersion estimates across all samples
DESeq.ds <- nbinomWaldTest(DESeq.ds) # this fits a negative binomial GLM and applies Wald statistics to each gene
DGE.results<- results (DESeq.ds, independentFiltering = TRUE , alpha = 0.05)
summary (DGE.results)
```


```{r}
4 # the DESeqResult object can basically be handled like a data . frame
5 > head ( DGE . results )
6 > table ( DGE . results $ padj < 0.05)
7 > rownames ( subset ( DGE . results , padj < 0.05) )

hist ( DGE . results $pvalue ,
2 col = " grey " , border = " white " , xlab = " " , ylab = " " ,
3 main = " frequencies of p - values "

 plotMA ( DGE . results , alpha = 0.05 , main = " WT vs . SNF2 mutants " ,
2 ylim = c( -4 ,4) )
 
 
 load the library with the aheatmap () function
2 > library ( NMF )
3
4 # aheatmap needs a matrix of values , e.g. , a matrix of DE genes with the
transformed read counts for each replicate
5 # sort the results according to the adjusted p- value
6 > DGE . results . sorted <- DGE . results [ order ( DGE . results $ padj ) , ]
7
8 # identify genes with the desired adjusted p- value cut -off
9 > DGEgenes <- rownames ( subset ( DGE . results . sorted , padj < 0.05) )
extract the normalized read counts for DE genes into a matrix
12 > hm . mat _ DGEgenes <- log. norm . counts [ DGEgenes , ]
13
14 # plot the normalized read counts of DE genes sorted by the adjusted p- value
15 > aheatmap ( hm .mat _ DGEgenes , Rowv = NA , Colv = NA )
16
17 # combine the heatmap with hierarchical clustering
18 > aheatmap ( hm .mat _ DGEgenes ,
19 Rowv = TRUE , Colv = TRUE , # add dendrograms to rows and columns
20 distfun = " euclidean " , hclustfun = " average " )
21
22 # scale the read counts per gene to emphasize the sample -type - specific
differences
23 > aheatmap ( hm .mat _ DGEgenes ,
24 Rowv = TRUE , Colv = TRUE ,
25 distfun = " euclidean " , hclustfun = " average " ,
26 scale = " row " ) # values are transformed into distances from the center
of the row - specific average : ( actual value - mean of the group ) /
standard deviation
```


Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Cmd+Option+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Cmd+Shift+K* to preview the HTML file). 

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.

