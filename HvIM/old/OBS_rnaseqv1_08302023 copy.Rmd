---
title: "DESeq_rna2_13_2023"
output: html_ntb.rmd
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code.

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*.

```{r setwd and Librarys}
setwd("~/Desktop/Lab/Coding                                     ")

library(magrittr)  #this will allow us to string commands together in a UNIX-pipe-like fashion using %>%
library(readr)
library(tidyverse)
library(ggplot2) #for making plots
library(ggrepel)
#library(DEGreport)
library(RColorBrewer)
library(DESeq2)
library(pheatmap)
library(S4Vectors)
library(stats4)
library(BiocGenerics)
library(knitr)
opts_chunk$set(echo = TRUE, message = FALSE,cache=FALSE) # tuning knitr output
#library(tximport)
library(plyr)
library(GGally)
library(dplyr)
library(mlbench)
#install.packages("viridis")
library(viridis)
#install.packages("hash")
library(vsn)
#install.packages("dendextend")
#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install()
#IF NEEDED , install the vsn package
#BiocManager::install(c("vsn"))
```

```{r Manipulating data, naming and other info}
featcount <- read_table("featcount.txt", 
                        col_names = TRUE, skip = 1)
read.count <- data.frame(featcount,row.names = featcount$Geneid ) #gene ids stored as row names

read.count <- read.count [ ,-c(1:6)] #removes the columns without gene counts not the same as bottom row code

orig_names <- names (read.count) 


names(read.count) <- (c("IT2", "IT3", "IT4", "H1", "H3", "H4", "H5", "UT1", "UT2", "UT3", "IT5", "IT6", "IT7", "IT8", "IM1", "IM2", "IM3", "IM4", "IM5", "UT4", "UT5", "UT6", "UT7", "UM1", "UM2", "UM3", "UM4", "UM5")) 

 sample_info <- data.frame(condition = gsub( "_[0 -9]+ " , " " , names(read.count),
),
    row.names = names(read.count))

sample_info 

glimpse(read.count)
#View(read.count)


#names(read.count) <- as.factor(c(paste("IT", c(2:4), sep = "_"),
 #                                paste("H", c(1:5), sep="_"),
  #                               paste("UT", c(1:3), sep="_"),
     #                            paste("IT", c(6:8), sep = "_"),
    #                             paste("IM", c(1:5), sep="_"),
       #                          paste("UT", c(4:6), sep = "_"),
      #                           paste("UM", c(1:5), sep = "_")))
#note: this works but causes an issue in the sample info step
```


```{r Manipulating data, naming and other info}

names(read.count) <- as.factor(c("IT2", "IT3", "IT4", "H1", "H3", "H4", "H5", "UT1", "UT2", "UT3", "IT5", "IT6", "IT7", "IT8", "IM1", "IM2", "IM3", "IM4", "IM5", "UT4", "UT5", "UT6", "UT7", "UM1", "UM2", "UM3", "UM4", "UM5")) 

#Corresponding names and conditions, make sure everything matches up at this point
#DIC	- > IT infected, 
#DIT - >	H infected, 
#DMC - >	UT mock, 
#PIC	- > IT infected
#PIT	- > IM infected
#PMC	- > UT mock
#PMT	- > UM mock


#make a data frame, row names should match sample names
sample_info <- data.frame(condition = gsub( "_[0 -9]+ " , " " , names(read.count),
),
    row.names = names(read.count))

sample_info


```


```{r DESeq set up}
#for installing the program if necessary
#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install(c("DESeq2"))


      #Differential Expression with DESeq2
# DESeq2 will model the raw counts, using normalization factors (size factors) to account for differences in library depth.
# Then, it will estimate the gene-wise dispersion and shrink these estimates to generate more accurate estimates of dispersion to model the counts.
# Finally, DESeq2 will fit the negative binomial model and perform hypothesis testing using the Wald test or Likelihood Ratio Test.

DESeq.ds <- DESeqDataSetFromMatrix(countData = read.count,
                                   colData = sample_info,
                                   design = ~condition)
DESeq.ds

head(counts(DESeq.ds))
counts(DESeq.ds) %>% str
colSums(counts(DESeq.ds))
colSums(counts(DESeq.ds)) %>% barplot(col="blueviolet")
```


```{r}
#to compare the gene expression between two conditions, we need 2 calculate the fraction of the reads assigned to each gene relative to the total number of reads and with respect to the entire RNA repertoire which may vary drastically from sample to sample. 

#While the number of sequenced reads is known, the total RNA library and its complexity is unknown and variation between samples may be due to contamination as well as biological reasons. 

#The purpose of normalization is to eliminate systematic effects that are not associated with the biological differences of interest. 


# remove genes without any counts
dim(DESeq.ds)
keep_genes <- rowSums(counts(DESeq.ds)) >0
DESeq.ds <- DESeq.ds[keep_genes,]
dim(DESeq.ds)

counts(DESeq.ds) %>% str
assay(DESeq.ds) %>% str

```


```{r Normalizing for seq depth and RNA compostition diff}
# investigate different library sizes = sequencing depth
#colSums(counts(DESeq.ds))%>% barplot # should be the same as colSums (read.count), how many reads were counted for each sample/library size
#library size is the total number of reads sequenced or total mapped reads

#calculate size factor and add to the data set (size factor: median ratio for each sample)
DESeq.ds <-estimateSizeFactors(DESeq.ds)
plot(sizeFactors(DESeq.ds), colSums(counts(DESeq.ds)), 
     ylab="library sizes", xlab = "size factors", cex = .6, col = "mediumvioletred")



#set up the plotting layout
par(mfrow=c(1,2))
counts.sf_normalized <- data.frame(counts(DESeq.ds, normalized = TRUE))
countsnorm <- data.frame(counts.sf_normalized)
summary(countsnorm)
##adding boxplots
##p <- ggplot(counts.sf_normalized, mapping = aes(x=condition)) + 
##  guides(fill=none) + coord_flip()
##p + geom_boxplot()

boxplot(countsnorm, main = "SF normalized")
boxplot(counts(DESeq.ds), main = "read counts only")

par(mfrow=c(1,2))
boxplot(log2(counts(DESeq.ds)), notch=TRUE, horizontal = TRUE,
        main = "Non-normalized read counts\n(log-transformed",
        xlab="read counts",
        col="violet",
        border="black")

boxplot(log2(counts(DESeq.ds, normalize=TRUE)), notch=TRUE,
        main="Size-factor-normalized read counts\n(log-transformed)",
        ylab="read counts")
```


```{r}
####Check results 
#colData (DESeq.ds) %>% head
#assay (DESeq.ds) %>% head
#rowRanges (DESeq.ds) %>% head

#setting up plots
par(mfrow=c(1,1))

#extracting normalized counts
counts.sf_normalized<-counts(DESeq.ds, normalized=TRUE)

#adding boxplots
boxplot(counts.sf_normalized, main = "size factor normalized", cex=.6)
boxplot(counts(DESeq.ds), main="read counts only", cex=.6)

par(mfrow=c(1,2))
boxplot(log2(counts(DESeq.ds)+1), notch=TRUE,
        main="non-norm read counts",
        ylab="log2(read counts", cex=.6)
boxplot(log2(counts(DESeq.ds, normalize=TRUE)+1), notch=TRUE,
        main="Size factor norm read counts",
        ylab="log2(read counts", cex=.6)
```


```{r}
# non normalized read counts plus pseudocount
log.counts <- log2(counts(DESeq.ds, normalized = FALSE)+1)
assay(DESeq.ds, "log.counts") <- log2(counts(DESeq.ds, normalized = FALSE)+1)

#normalized read counts
log.norm.counts <- log2(counts(DESeq.ds, normalized = TRUE) + 1)

par(mfrow=c(1,1))
plot(log.norm.counts[,1:2], cex =.1 , main = "Normalized log2(read counts)", col = "turquoise")

#every dot= one gene, the wider lower part means that read counts correlate less well between replicated when they are low

#standard dev of the expression may depend on the mean (the lower the mean read counts per gene, the higher the standard deviation)
log.norm.counts<- log2(counts(DESeq.ds, normalized = TRUE)+1)

par(mfrow=c(1,1))
msd_plot <- vsn::meanSdPlot(log.norm.counts,
                            ranks = FALSE, 
                            plot = FALSE)
msd_plot$gg +
  ggtitle("seq depth normalized log2(read counts")+
  ylab("standard dev")

#red depict the running median estimator. 
#plot shows that there is some variance-mean dependence for genes with low read counts. means data shows signs of heteroskedasricity
```


```{r}
#reducing dependance on mean
DESeq.rlog<- rlog(DESeq.ds, blind=TRUE)

par(mfrow=c(1,1))
plot(log.norm.counts[,1:2], cex=.1,
     main = "size factor and log2 transformed",
     col="skyblue")

plot(assay(DESeq.rlog)[,1],
     assay(DESeq.rlog)[,2],
           cex=.1, main = "rlog transformed",
           xlab = colnames(assay(DESeq.rlog[,1])),
           ylab =colnames(assay(DESeq.rlog[,2])),
     col="thistle")

rlog.norm.counts<-assay(DESeq.rlog)
```


```{r}
#rlog-transformed read counts and mean sd 
msd_plot <-vsn::meanSdPlot(rlog.norm.counts, ranks=FALSE, plot = FALSE)
msd_plot$gg + ggtitle("rlog transformation") + coord_cartesian(ylim = c(0,3))

#adjusted at this point, differences in sequencing depth, differences in RNA composition, heteroskedasticity, large dynamic range so we can use it for exploratory analysis- de analyses

save.image(file = "RNAseqkasia.RDATA")
```


```{r}

#infected vs mock
infected_roots<- (rlog.norm.counts[,c('IT2', 'IT3', 'IT4', 'H1', 'H3', 'H4', 'H5', 'IT5', 'IT6', 'IT7', 'IT8', 'IM1', 'IM2', 'IM3', 'IM4', 'IM5')] )
mock_roots <- (rlog.norm.counts[,c("UT1", "UT2", "UT3","UT4", "UT5", "UT6", "UT7", "UM1", "UM2", "UM3", "UM4", "UM5")])

#DMR6 vs PETE
DMR6_roots<- (rlog.norm.counts[,c("IT2", "IT3", "IT4", "H1", "H3", "H4", "H5", "UT1", "UT2", "UT3")])
PETE_roots<-(rlog.norm.counts[,c("IT5", "IT6", "IT7", "IT8", "IM1", "IM2", "IM3", "IM4", "IM5", "UT4", "UT5", "UT6", "UT7", "UM1", "UM2", "UM3", "UM4", "UM5")])

#transcriptome vs translatome
transcriptome<- (rlog.norm.counts[,c("IT2", "IT3", "IT4", "UT1", "UT2", "UT3", "IT5", "IT6", "IT7", "IT8", "UT4", "UT5", "UT6", "UT7")])
translatome<- (rlog.norm.counts[,c("H1", "H3", "H4", "H5","IM1", "IM2", "IM3", "IM4", "IM5","UM1", "UM2", "UM3", "UM4", "UM5")])

head(infected_roots)
```


```{r looking to see relationships between conditions}
# cor () calculates the correlation between columns of a matrix
distance.m_rlog <- as.dist(1-(cor(rlog.norm.counts, method = "pearson")) )
all_gene_tree <- hclust(distance.m_rlog, method = "complete")

# dendrogram plot () can directly interpret the output of hclust ()
#plot(all_gene_tree,
#     labels = colnames(rlog.norm.counts), cex=0.9,
#     main = "rlog transformed read counts\ndistance: Pearson correlation")



library(dendextend)
dend_allg<-as.dendrogram(all_gene_tree)

nleaves(dend_allg) # # of genes we clustered
nnodes(dend_allg) # # of nodes (leaves+joins) in tree

allg_clusters <- cutree(dend_allg, k=8, order_clusters_as_data = FALSE)
table(allg_clusters)
allg_clusters[1:6]

plot(color_branches(dend_allg, k=8, leaflab="none"))

allgenecluster.df <-data.frame(Condition=names(allg_clusters), cluster = allg_clusters)
allgenecluster3<-filter(allgenecluster.df, cluster==3)
cat(as.character(allgenecluster3[1]), quote=FALSE, sep = "\n");

#https://bio723-class.github.io/Bio723-book/clustering-in-r.html

```


```{r looking to see relationships between conditions}

#principle component analysis
pc <- prcomp(t(rlog.norm.counts))
plot(pc$x[,1], pc$x[,2],
     col = colData(DESeq.ds) [,1], 
     main = "PCA of seq.depth normalized\n and rlog-transformed read counts")
```

```{r}
 # PCA
P <-plotPCA(DESeq.rlog)

# plot cosmetics
P <- P + theme_bw() + ggtitle("Rlog transformed counts")
print(P)
```

```{r}
# DESeq uses the levels of the condition to determine the order of the comparison
str(colData(DESeq.ds)$condition)

# set WT as the first -level - factor
colData(DESeq.ds)$condition <- relevel(colData(DESeq.ds)$condition, "UM1","UM2","UM3","UM4","UM5","UT1","UT2","UT3","UT4","UT5","UT6","UT7")


DESeq.ds<-DESeq(DESeq.ds)
```

```{r}
DESeq.ds <- estimateSizeFactors(DESeq.ds) # sequencing depth normalization between the samples
DESeq.ds <- estimateDispersions(DESeq.ds, fitType = c("parametric", "local", "mean"), maxit = 100, quiet = FALSE, modelMatrix = NULL) # gene - wise dispersion estimates across all samples
DESeq.ds <- nbinomWaldTest(DESeq.ds) # this fits a negative binomial GLM and applies Wald statistics to each gene
DGE.results<- results (DESeq.ds, independentFiltering = TRUE , alpha = 0.05)
summary (DGE.results)
```

```{r}
# the DESeqResult object can basically be handled like a data . frame
head(DGE.results)
table(DGE.results$padj<0.05)
rownames(subset(DGE.results,padj<0.05))

hist(DGE.results$pvalue,
col="grey", border="white", xlab="", ylab ="",
main = "frequencies of p-values"

plotMA (DGE.results, alpha=0.05 , main="WTvs.SNF2 mutants",
ylim = c(-4,4))
 
 
# load the library with the aheatmap () function
library(NMF)
 
# aheatmap needs a matrix of values , e.g. , a matrix of DE genes with the transformed read counts for each replicate
# sort the results according to the adjusted p- value
DGE.results.sorted <- DGE.results[order(DGE.results$padj),]

# identify genes with the desired adjusted p- value cut -off
DGEgenes <- rownames ( subset ( DGE . results . sorted , padj < 0.05) )
#extract the normalized read counts for DE genes into a matrix
hm . mat _ DGEgenes <- log. norm . counts [ DGEgenes , ]

# plot the normalized read counts of DE genes sorted by the adjusted p- value
aheatmap ( hm .mat _ DGEgenes , Rowv = NA , Colv = NA )

# combine the heatmap with hierarchical clustering
aheatmap ( hm .mat _ DGEgenes ,
Rowv = TRUE , Colv = TRUE , # add dendrograms to rows and columns
distfun = " euclidean " , hclustfun = " average " )

# scale the read counts per gene to emphasize the sample -type - specific
differences
aheatmap ( hm .mat _ DGEgenes ,
Rowv = TRUE , Colv = TRUE ,
distfun = " euclidean " , hclustfun = " average " ,
scale = " row " ) # values are transformed into distances from the center of the row - specific average : ( actual value - mean of the group ) /standard deviation
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Cmd+Option+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Cmd+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
