---
title: "Kasia Data"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

```{r SETUP}

setwd("~/Desktop/Lab/Coding")
```


```{r SET UP}
library(readr)
featcount <- read_table("featcount.txt", 
                        col_names = TRUE, skip = 1)
read.count <- data.frame(featcount,row.names = featcount$Geneid ) #gene ids stored as row names
geneID<- featcount$Geneid

read.count <- read.count [ ,-c(1:6)] #removes the columns without gene counts not the same as bottom row code

orig_names <- names (read.count)
```

```{r SET UP 3}
kasia.count <- read.count [ ,-c(10,21:22,25:26)]
#"UM3", "UM4, "UT6", "UT7", ut3, #ut1

colnames(kasia.count) <- (c("IT2", "IT3", "IT4", "H1", "H3", "H4", "H5","UT1", "UT2", "IT5", "IT6", "IT7", "IT8", "IM1", "IM2", "IM3", "IM4", "IM5", "UT4", "UT5", "UM1", "UM2", "UM5")) 
#view(kasia.count)

sample_infoK <- data.frame(
   sample = c("IT2", "IT3", "IT4", "H1", "H3", "H4", "H5", "UT1", "UT2", "IT5", "IT6", "IT7", "IT8", "IM1", "IM2", "IM3", "IM4", "IM5", "UT4", "UT5", "UM1", "UM2", "UM5"),
   condition = c("infected","infected","infected","infected","infected","infected","infected","mock","mock","infected","infected","infected","infected","infected","infected","infected","infected","infected","mock","mock","mock","mock","mock"),
   treatment=c("IT", "IT", "IT", "H", "H", "H", "H", "UT", "UT", "IT", "IT", "IT", "IT", "IM", "IM", "IM", "IM", "IM", "UT", "UT", "UM", "UM", "UM"),
   translation= c("all","all","all","translated","translated","translated","translated", "all","all","translated","translated","translated","translated","all","all","all","all","all", "translated","translated","translated","translated","translated"),
    replicate = c("IT2", "IT3", "IT4", "H1", "H3", "H4", "H5", "UT1", "UT2", "IT5", "IT6", "IT7", "IT8", "IM1", "IM2", "IM3", "IM4", "IM5", "UT4", "UT5", "UM1", "UM2", "UM5"),
   row.names = "sample")
#sample_info$treatment<- as.factor(sample_info$treatment)
#sample_info$condition<- as.factor(sample_info$condition)
#all(rownames(sample_info) %in% colnames(read.count)) #if false something is wrong
sample_infoK 
```

```{r SET UP 4}
library(DESeq2)

dds <- DESeqDataSetFromMatrix(countData = kasia.count,
                              colData = sample_infoK,
                              design = ~ treatment)
print(dds)

```

```{r Normalizing}
library(magrittr)

#not sure about col sum vs row sums

#prefiltering

dds <- dds[ rowSums( counts(dds) ) > 10 , ]


#we can plot how many reads we have for each sample
colSums(assay(dds))
barplot(colSums(assay(dds)), names=colnames(dds$replicate), las=2, main ="barplot of lib sizes", col = "turquoise")


# calculate the size factor and add it to the data set
dds <- estimateSizeFactors (dds)
sizeFactors(dds)

# counts () allows you to immediately retrieve the _ normalized _ count reads
counts.sf_normalized <- counts(dds, normalized = TRUE)
```


```{r Normalized but still raw counts}
par( mfrow =c(1 ,1)) # to plot the following two images underneath each other

# first , boxplots of non - transformed read counts (one per sample )
boxplot(counts.sf_normalized, notch = TRUE,
        main = "Non Normalized read counts", 
        ylab = "read counts")


# Raw counts mean expression Vs standard Deviation (SD)
plot(rowMeans(counts.sf_normalized), rowSds(counts.sf_normalized), 
     main='Raw counts: sd vs mean', 
     xlim=c(0,10000),
     ylim=c(0,5000))
```


```{r log fold}
#Count data is not normally distributed, so if we want to examine the distributions of the raw counts it is helpful to transform the data on to a log scale. Typically we use a log2 transformation, however, because the data is count data and will contain many 0s we need to add a count of 1 to every value in order to prevent attempting log2(0) from creating errors. Because some genes are not expressed (detected) in some samples, their count are 0. As log2(0) returns -Inf in R which triggers errors by some functions, we add 1 to every count value to create ‘pseudocounts’. The lowest value then is 1, or 0 on the log2 scale (log2(1) = 0).

#To avoid problems posed by raw counts, they can be transformed. Several transformation methods exist to limit the dependence of variance on mean gene expression:

#Simple log2 transformation
#VST : variance stabilizing transformation
#rlog : regularized log transformation


log.norm.counts <- log2 (counts.sf_normalized + 1)
statusCol <- match(sample_infoK$condition, c("mock", "infected"))+1
 
# box plots of log2 - transformed read counts, check distributions of samples
boxplot (log.norm.counts, 
         notch = TRUE, 
         col= statusCol,
            main = "log2 - transformed read counts ",
            ylab = " log2 ( read counts )")
abline(h=median(as.matrix(log.norm.counts)), col="blue")

# Log2 counts standard deviation (sd) vs mean expression
plot(rowMeans(log.norm.counts), rowSds(log.norm.counts), 
     main='Log2 Counts: sd vs mean')
```

```{r}
library(vsn)
library(ggplot2)
library(pheatmap)
library(RColorBrewer)

rld <- rlog(dds, blind=FALSE)
Dists <- dist(t( assay(rld) ) )


DistMatrix <- as.matrix( Dists )
rownames(DistMatrix) <- paste( rld$treatment, sep="-" )
colnames(DistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(DistMatrix,
 clustering_distance_rows=Dists,
 clustering_distance_cols=Dists,
 col=colors)


```



```{r}
# PCA
library(ggfortify)
library(ggrepel)
library (ggplot2)
library (DESeq2)
library(pheatmap)


plotPCA(rld, 
             intgroup="treatment") + geom_text_repel(aes(x=PC1, y=PC2, label=sample_infoK$replicate), box.padding = 0.3)  +theme_bw () + ggtitle (" Rlog transformed counts ")
```

```{r}
library(dendextend)
library(ggplot2)
library(stats)


all_gene_tree <- hclust(Dists, method = "complete")

dend_allg<-as.dendrogram(all_gene_tree)

nleaves(dend_allg) # # of genes we clustered
nnodes(dend_allg) # # of nodes (leaves+joins) in tree

allg_clusters <- cutree(dend_allg, k=4, order_clusters_as_data = FALSE)
table(allg_clusters)
allg_clusters[1:6]

plot(color_branches(dend_allg, k=4, leaflab="none"),
     main = "rlog transformed read counts\ndistance: Pearson correlation",
     xlab = NULL, ylab ="Height")

allgenecluster.df <-data.frame(Condition=names(allg_clusters), cluster = allg_clusters)

#https://bio723-class.github.io/Bio723-book/clustering-in-r.html

```



```{r}
library(vsn)
library(pheatmap)


#ntd<- normTransform(dds)
vsd<-vst(dds)
plotPCA(vsd)



pheatmap(assay(vsd))
pheatmap(assay(rld))

library("RColorBrewer")

rownames(DistMatrix) <- paste(vsd$condition, vsd$type, sep="-")
colnames(DistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(DistMatrix,
         clustering_distance_rows=Dists,
         clustering_distance_cols=Dists,
         col=colors)
```


```{r}
dseq<-DESeq(dds)
res <- results(dseq)
mcols(res, use.names=TRUE)
summary(res)

```


