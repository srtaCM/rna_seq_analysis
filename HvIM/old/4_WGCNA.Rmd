---
title: "Weighted Gene Correlation Network Analysis"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

```{r}
### INSTALLING PACKAGES ###
#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install(c("readr", "tidyverse", "org.At.tair.db", "pathview","dplyr"))

# Clean environment
rm(list = ls(all.names = TRUE)) # will clear all objects including hidden objects
gc() # free up memory and report the memory usage
options(max.print = .Machine$integer.max, scipen = 0, stringsAsFactors = F, dplyr.summarise.inform = F) # avoid truncated output in R console and keep scientific notation

setwd("~/Desktop/Lab/Working_Projects/trapseq_2023")
suppressPackageStartupMessages(library("org.At.tair.db"))
suppressPackageStartupMessages(library(DESeq2))
library(clusterProfiler) #A universal enrichment tool for interpreting omics data #prettydoc?
library(readr)
library(tidyverse) #to use distinct in line 52
library(pathview)
library(enrichplot)
library(dplyr)
library(tibble)
library(magrittr)
library(WGCNA)
```

```{r}
countData<- read_csv("degDESeqDataSetFromMatrix.csv")
countData.df <- data.frame(countData, row.names = countData$...1 )

# ── Column specification ────────────────────────────────────────────────────────
 cols(
   .default = col_double(),
   Count = col_character()
 )
#> ℹ Use `spec()` for the full column specifications.

countData.df[1:5,1:10]        # Look at first 5 rows and 10 columns

#str(data)           # str = structure of data, useful for debugging data type mismatch errors

names(countData.df)[1] = "GeneId"
names(countData.df)           # Look at the column names
```


```{r}
col_sel = names(countData.df)[-1]     # Get all but first column name
mdata <- countData.df %>%
  tidyr::pivot_longer(
    .,                        # The dot is the the input data (magrittr tutorial)
    col = all_of(col_sel)
    ) %>%   
  mutate( group = gsub("-.*","", name) %>% gsub("[.].*","", .)   # Get the shorter treatment names
          )


# Optional step ---  order the groups in the plot.
mdata$group = factor(mdata$group, 
                     levels = c("H","IM", "UM"))  #<= fill the rest of this in
summary(mdata$group)
```


```{r idk what this plot means}
# ==== Plot groups (Sample Groups vs RNA Seq Counts) to identify outliers
(
 p <- mdata %>%
    ggplot(., aes(x = name, y = value)) +             # x = treatment, y = RNA Seq count
    geom_violin() +                                   # violin plot, show distribution
    geom_point(alpha = 0.2) +                         # scatter plot
    theme_bw() +
    theme(
      axis.text.x = element_text(angle = 90)          # Rotate treatment text
    ) +
    labs(x = "Treatment Groups", y = "RNA Seq Counts") +
    facet_grid(cols = vars(group), drop = TRUE, scales = "free_x")      # Facet by hour?
)

```





```{r}
de_input = as.matrix(countData.df[,-1])
row.names(de_input) = countData.df$GeneId
de_input[1:5,1:10]
#str(de_input)

meta_df <- data.frame( Sample = names(countData.df[-1])) %>%
  mutate(
    Type = gsub("-.*","", Sample) %>% gsub("[.].*","", .)
  )

dds <- DESeqDataSetFromMatrix(round(de_input),
                              meta_df,
                              design = ~Type)
```


```{r}
dds <- DESeq(dds)
```


```{r}
dds <- dds[ rowSums(counts(dds)) > 10, ] 
dat0<-assay(dds)

```



```{r}
get_vsd <- getVarianceStabilizedData(dds)

colnames(get_vsd)<- colData(dds)$GeneID
vsd2 <- t(get_vsd)    
datExpr<- vsd2

gsg = goodSamplesGenes(datExpr, verbose = 5);
gsg$allOK ##If the last statement returns TRUE, all genes have passed the cuts.
```


```{r}
library(genefilter)      # <= why is this here?

get_vsd <- getVarianceStabilizedData(dds)
rv_get <- rowVars(get_vsd)
summary(rv_get)

#q25_get <- quantile( rowVars(get_vsd), .25)
#q75_get <- quantile( rowVars(get_vsd), .75)  # <= original
q95_get <- quantile( rowVars(get_vsd), .95)  # <= changed to 95 quantile to reduce dataset
expr_normalized <- get_vsd[ rv_get > q95_get, ]

expr_normalized[1:5,1:10]
dim(expr_normalized)


expr_normalized_df <- data.frame(expr_normalized) %>%
  mutate(
    Gene_id = row.names(expr_normalized)
  ) %>%
  pivot_longer(-Gene_id)

expr_normalized_df %>% ggplot(., aes(x = name, y = value)) +
  geom_violin() +
  geom_point() +
  theme_bw() +
  theme(
    axis.text.x = element_text( size = 20, angle = 90), axis.title=element_text(size=20)
  ) +
  ylim(0, NA) +
  labs(
    title = "Normalized and 95 quantile Expression",
    x = "treatment",
    y = "normalized expression"
  )
#ggsave("Normalized_95_quantile_Express_violin.png",width=16, height =16) 
```


```{r}
input_mat = t(expr_normalized)

input_mat[1:5,1:10]           # Look at first 5 rows and 10 columns

```


```{r}
library(WGCNA)
allowWGCNAThreads()          # allow multi-threading (optional)
#The soft thresholding, is a value used to power the correlation of the genes to that threshold. The assumption on that by raising the correlation to a power will reduce the noise of the correlations in the adjacency matrix. To pick up one threshold use the pickSoftThreshold function, which calculates for each power if the network resembles to a scale-free graph. The power which produce a higher similarity with a scale-free network is the one you should use.

# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to = 20, by = 2))

# Call the network topology analysis function
sft = pickSoftThreshold(
  input_mat,             # <= Input data
  #blockSize = 30,
  powerVector = powers,
  verbose = 5
  )
sft = pickSoftThreshold(input_mat,corFnc = "bicor", corOptions=list(maxPOutliers=0.1), #testing
                        networkType = "signed hybrid", powerVector = powers, verbose = 5)

sizeGrWindow(12, 9)
par(mfrow = c(1,2));
cex1 = 0.9;

plot(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     xlab = "Soft Threshold (power)",
     ylab = "Scale Free Topology Model Fit, signed R^2",
     main = paste("Scale independence")
);
text(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     labels = powers, cex = cex1, col = "red"
);
abline(h = 0.90, col = "red")

```


```{r}
plot(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     xlab = "Soft Threshold (power)",
     ylab = "Mean Connectivity",
     type = "n",
     main = paste("Mean connectivity")
);
text(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     labels = powers,
     cex = cex1, col = "red")
```


```{r}
picked_power = 18
temp_cor <- cor       
cor <- WGCNA::cor # Force it to use WGCNA cor function (fix a namespace conflict issue)
netwk <- blockwiseModules(input_mat, # <= input here
 # == Adjacency Function ==
 power = picked_power, # <= power here
 networkType = "signed",
 # == Tree and Block Options ==
 deepSplit = 2,
 pamRespectsDendro = F,
 # detectCutHeight = 0.75,
 minModuleSize = 30,
 maxBlockSize = 4000,
 # == Module Adjustments ==
 reassignThreshold = 0,
 mergeCutHeight = 0.25,
 # == TOM == Archive the run results in TOM file (saves time)
 saveTOMs = T,
 saveTOMFileBase = "ER",
 # == Output Options
 numericLabels = T,
 verbose = 3)

cor <- temp_cor # Return cor function to original namespace

# Convert labels to colors for plotting
mergedColors = labels2colors(netwk$colors)
# Plot the dendrogram and the module colors underneath
plotDendroAndColors(
  netwk$dendrograms[[1]],
  mergedColors[netwk$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )
```
```{r}
#netwk$colors[netwk$blockGenes[[1]]]
#table(netwk$colors)
```



```{r}
module_df <- data.frame(
  gene_id = names(netwk$colors),
  colors = labels2colors(netwk$colors)
)

module_df[1:5,]

write_delim(module_df,
            file = "gene_modules.txt",
            delim = "\t")


```

```{r}
# Get Module Eigengenes per cluster
MEs0 <- moduleEigengenes(input_mat, mergedColors)$eigengenes

# Reorder modules so similar modules are next to each other
MEs0 <- orderMEs(MEs0)
module_order = names(MEs0) %>% gsub("ME","", .)

# Add treatment names
MEs0$treatment = row.names(MEs0)

# tidy & plot data
mME = MEs0 %>%
  pivot_longer(-treatment) %>%
  mutate(
    name = gsub("ME", "", name),
    name = factor(name, levels = module_order)
  )

mME %>% ggplot(., aes(x=treatment, y=name, fill=value)) +
  geom_tile() +
  theme_bw() +
  scale_fill_gradient2(
    low = "blue",
    high = "red",
    mid = "white",
    midpoint = 0,
    limit = c(-1,1)) +
  theme(axis.text.x = element_text( size = 15, angle = 90), axis.title=element_text(size=15)) + labs(title = "Module-trait Relationships", y = "Modules", fill="corr")
#ggsave("module_trait_relationships.png",width=16, height =16) 

#Looking at the heatmap, the green seems positively associated (red shading) with the L groups, turquoise module is positive for the L but negative (blue shading) for the L_L1 groups, and tan module is positive in the S groups but negative elsewhere. There are other patterns, think about what the patterns mean. For this tutorial we will focus on the green, turquoise, and tan module genes.
```

```{r}
# pick out a few modules of interest here
modules_of_interest = c("turquoise", "blue", "brown", "grey")


# Pull out list of genes in that module
submod = module_df %>%
  subset(colors %in% modules_of_interest) #%>%  
 # write_csv(, file = "turqgene_modules.csv")

row.names(module_df) = module_df$gene_id

# Get normalized expression for those genes
expr_normalized[1:5,1:10]

subexpr = expr_normalized[submod$gene_id,]

submod_df = data.frame(subexpr) %>%
  mutate(
    gene_id = row.names(.)
  ) %>%
  pivot_longer(-gene_id) %>%
  mutate(
    module = module_df[gene_id,]$colors
  )

submod_df %>% ggplot(., aes(x=name, y=value, group=gene_id)) +
  geom_line(aes(color = module),
            alpha = 0.2) +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90)
  ) +
  facet_grid(rows = vars(module)) +
  labs(x = "treatment",
       y = "normalized expression")
ggsave("normalized_expression.png",width=16, height =16) 

#It is possible to plot the modules in green, tan, and turquoise colors but for now we’ll use the auto colors generated by ggplot2. From the expression line graph, the line graph matches the correlation graph where Green module genes are higher in the L groups. Tan genes seem higher in the S groups, and Turquoise genes are low at L_L1 and S_L1 and maybe B_L1 groups.
```


```{r}
genes_of_interest = module_df %>%
  subset(colors %in% modules_of_interest)

expr_of_interest = expr_normalized[genes_of_interest$gene_id,]
expr_of_interest[1:5,1:5]

# Only recalculate TOM for modules of interest (faster, altho there's some online discussion if this will be slightly off)
TOM = TOMsimilarityFromExpr(t(expr_of_interest),
                            power = picked_power)


# Add gene names to row and columns
row.names(TOM) = row.names(expr_of_interest)
colnames(TOM) = row.names(expr_of_interest)

edge_list = data.frame(TOM) %>%
  mutate(
    gene1 = row.names(.)
  ) %>%
  pivot_longer(-gene1) %>%
  dplyr::rename(gene2 = name, correlation = value) %>%
  unique() %>%
  subset(!(gene1==gene2)) %>%
  mutate(
    module1 = module_df[gene1,]$colors,
    module2 = module_df[gene2,]$colors
  )

head(edge_list)



# Export Network file to be read into Cytoscape, VisANT, etc
write_delim(edge_list,
            file = "edgelist.tsv",
            delim = "\t")

#input:
#GSE61333_ligule_count.txt - RNASeq counts
#Output:
#gene_modules.txt - Lists genes and their WGCNA modules
#edge_list.tsv - Gene correlation network for modules of interest
```


```{r}
# davids script

gsg = goodSamplesGenes(dat0, verbose = 5);    
gsg$allOK
colnames(get_vsd)<- colData(dds)$Written.ID    
vsd2 <- t(get_vsd)    
datExpr<- vsd2

powers = c(c(1:10), seq(from = 12, to=20, by=2))
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
sft = pickSoftThreshold(datExpr,corFnc = "bicor", corOptions=list(maxPOutliers=0.1),
                        networkType = "signed hybrid", powerVector = powers, verbose = 5)


softpower = 6
nethybrid = blockwiseModules(datExpr, power = softpower,maxBlockSize = 30000,
                             TOMType = "signed", minModuleSize = 30,
                             reassignThreshold = 0, mergeCutHeight = 0.25,
                             numericLabels = TRUE, pamRespectsDendro = FALSE,
                             saveTOMs = FALSE, networkType = "signed hybrid",
                             verbose = 5,corType = "bicor", maxPOutliers = 0.1,
                             pearsonFallback = "individual")
table(nethybrid$colors)

sizeGrWindow(12, 9)

mergedColors = labels2colors(nethybrid$colors)

plotDendroAndColors(nethybrid$dendrograms[[1]], mergedColors[nethybrid$blockGenes[[1]]],
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)

datME=moduleEigengenes(datExpr,nethybrid$colors)$eigengenes
signif(cor(datME, use="p"), 2)

dissimME=(1-t(cor(datME, method="p")))/2
hclustdatME=hclust(as.dist(dissimME), method="average" )

par(mfrow=c(1,1))
plot(hclustdatME, main="Clustering tree based of the module eigengenes")
sizeGrWindow(8,9)

plotMEpairs(datME)
#signif(cor(datME, ModuleEigengeneNetwork1[,-1]),2)


sizeGrWindow(8,9)
par(mfrow=c(3,1), mar=c(1, 2, 4, 1))
which.module="turquoise";
plotMat(t(scale(datExpr[,moduleColors==which.module ]) ),nrgcols=30,rlabels=T,
        clabels=T,rcols=which.module,
        title=which.module )
which.module="blue";
plotMat(t(scale(datExpr[,moduleColors==which.module ]) ),nrgcols=30,rlabels=T,
        clabels=T,rcols=which.module,
        title=which.module )
which.module="yellow";
plotMat(t(scale(datExpr[,moduleColors==which.module ]) ),nrgcols=30,rlabels=T,
        clabels=T,rcols=which.module,
        title=which.module )

datExpr0 = as.data.frame(input_mat)
names(datExpr0)=atha$Geneid
#rownames(dat0)=names(atha)[-1]
datExpr0[] = lapply(dat0, as.numeric)

#checking for the missing values and remotion of NA
gsg = goodSamplesGenes(dat0, verbose = 3);
gsg$allOK
#if it is not
if (!gsg$allOK)
{
  # Optionally, print the gene and sample names that were removed:
  if (sum(!gsg$goodGenes)>0)
    printFlush(paste("Removing genes:", paste(names(datExpr0)[!gsg$goodGenes], collapse = ", ")));
  if (sum(!gsg$goodSamples)>0)
    printFlush(paste("Removing samples:", paste(rownames(datExpr0)[!gsg$goodSamples], collapse = ", ")));
  # Remove the offending genes and samples from the data:
  datExpr0 = datExpr0[gsg$goodSamples, gsg$goodGenes]
  
  #exprSize = checkSets(datExpr0)
}

sampleTree = hclust(dist(datExpr), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
sizeGrWindow(12,9)
#pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,
     cex.axis = 1.5, cex.main = 2)
# Plot a line to show the cut
abline(h = 355, col = "red");
# Determine cluster under the line
clust = cutreeStatic(sampleTree, cutHeight = 355, minSize = 10)
table(clust)
# clust 1 contains the samples we want to keep.
keepSamples = (clust==1)
datExpr = datExpr[keepSamples, ]
nGenes = ncol(datExpr)
nSamples = nrow(datExpr)

sampleTree = hclust(dist(datExpr), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
sizeGrWindow(12,9)
#pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,
     cex.axis = 1.5, cex.main = 2)

#how to detect outliers
library(rrcov)
pcaHub = PcaHubert(datExpr)
outliers = which(pcaHub@flag =="FALSE")

# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=20, by=2))
# Call the network topology analysis function
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
# Plot the results:
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")

net = blockwiseModules(datExpr, power = 6,
                       TOMType = "unsigned", maxBlockSize = 30000, minModuleSize = 30,
                       reassignThreshold = 0, mergeCutHeight = 0.89,
                       numericLabels = TRUE, pamRespectsDendro = FALSE,
                       saveTOMs = TRUE,
                       saveTOMFileBase = "spimp_TOM",
                      verbose = 3)

table(nethybrid$colors)
# open a graphics window
sizeGrWindow(12, 9)
# Convert labels to colors for plotting
mergedColors = labels2colors(net$colors)
# Plot the dendrogram and the module colors underneath
plotDendroAndColors(net$dendrograms[[1]], mergedColors[net$blockGenes[[1]]],
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)


#module assignment
moduleLabels = nethybrid$colors
moduleColors = labels2colors(nethybrid$colors)
#module eigengene
MEs = nethybrid$MEs
geneTree = nethybrid$dendrograms[[1]]

traitData=read.csv("jh_metadata.csv")

pcapSamples = rownames(datExpr0);
traitRows = match(pcapSamples, traitData$Sample);
traitRows

datTraits = traitData[traitRows, -1];
rownames(datTraits) = traitData[traitRows, 1];
datTraits[] = lapply(datTraits, as.numeric)


# Re-cluster samples
sampleTree2 = hclust(dist(datExpr), method = "average")
# Convert traits to a color representation: white means low, red means high, grey means missing entry
traitColors = numbers2colors(datTraits, signed = FALSE);
# Plot the sample dendrogram and the colors underneath.
plotDendroAndColors(sampleTree2, traitColors,
                    groupLabels = names(datTraits),
                    main = "Sample dendrogram and trait heatmap")

names(datExpr0)


# Define numbers of genes and samples
nGenes = ncol(datExpr);
nSamples = nrow(datExpr);
# Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr, moduleColors)$eigengenes
MEs = orderMEs(MEs0)
moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);

sizeGrWindow(10,6)
# Will display correlations and their p-values
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                   signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)
par(mar = c(6, 8.5, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = names(datTraits),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = greenWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module-trait relationships"))

#=====================================================================================
#
#  Code chunk 4
#
#=====================================================================================


# Define variable weight containing the weight column of datTrait
iron = as.data.frame(datTraits$DPI);
names(dpi) = "Dpi"
# names (colors) of the modules
modNames = substring(names(MEs), 3)

geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"));
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples));

names(geneModuleMembership) = paste("MM", modNames, sep="");
names(MMPvalue) = paste("p.MM", modNames, sep="");

geneTraitSignificance = as.data.frame(cor(datExpr, iron, use = "p"));
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples));

names(geneTraitSignificance) = paste("GS.", names(iron), sep="");
names(GSPvalue) = paste("p.GS.", names(iron), sep="");


#=====================================================================================
#
#  Code chunk 5
#
#=====================================================================================


module = "lightcyan"
column = match(module, modNames);
moduleGenes = moduleColors==module;

sizeGrWindow(7, 7);
par(mfrow = c(1,1));
verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
                   abs(geneTraitSignificance[moduleGenes, 1]),
                   xlab = paste("Module Membership in", module, "module"),
                   ylab = "Gene significance for body weight",
                   main = paste("Module membership vs. gene significance\n"),
                   cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module, )


#=====================================================================================
#
#  Code chunk 6
#
#=====================================================================================


names(datExpr)


#=====================================================================================
#
#  Code chunk 7
#
#=====================================================================================


iron_name=names(datExpr)[moduleColors=="lightcyan"]
write(iron_name, file ="iron_names.txt", sep = "\t")

#=====================================================================================
#
#  Code chunk 8
#
#=====================================================================================


annot = read.csv(file = "GeneAnnotation.csv");
dim(annot)
names(annot)
probes = names(datExpr)
probes2annot = match(probes, annot$substanceBXH)
# The following is the number or probes without annotation:
sum(is.na(probes2annot))
# Should return 0.


#=====================================================================================
#
#  Code chunk 9
#
#=====================================================================================


# Create the starting data frame
geneInfo0 = data.frame(substanceBXH = probes,
                       geneSymbol = annot$gene_symbol[probes2annot],
                       LocusLinkID = annot$LocusLinkID[probes2annot],
                       moduleColor = moduleColors,
                       geneTraitSignificance,
                       GSPvalue)
# Order modules by their significance for weight
modOrder = order(-abs(cor(MEs, weight, use = "p")));
# Add module membership information in the chosen order
for (mod in 1:ncol(geneModuleMembership))
{
  oldNames = names(geneInfo0)
  geneInfo0 = data.frame(geneInfo0, geneModuleMembership[, modOrder[mod]], 
                         MMPvalue[, modOrder[mod]]);
  names(geneInfo0) = c(oldNames, paste("MM.", modNames[modOrder[mod]], sep=""),
                       paste("p.MM.", modNames[modOrder[mod]], sep=""))
}
# Order the genes in the geneInfo variable first by module color, then by geneTraitSignificance
geneOrder = order(geneInfo0$moduleColor, -abs(geneInfo0$GS.weight));
geneInfo = geneInfo0[geneOrder, ]




TOM = TOMsimilarityFromExpr(datExpr, power = 6);
modules = c("brown", "lightcyan");
probes = names(datExpr)
inModule = is.finite(match(moduleColors, modules));
modProbes = probes[inModule];

modTOM = TOM[inModule, inModule];
dimnames(modTOM) = list(modProbes, modProbes)
cyt = exportNetworkToCytoscape(modTOM,
                               edgeFile = paste("CytoscapeInput-edges-", paste(modules, collapse="-"), ".txt", sep=""),
                               nodeFile = paste("CytoscapeInput-nodes-", paste(modules, collapse="-"), ".txt", sep=""),
                               weighted = TRUE,
                               threshold = 0.05,
                               nodeNames = modProbes,
                               altNodeNames = modProbes,
                               nodeAttr = moduleColors[inModule]);



```


