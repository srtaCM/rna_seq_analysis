---
title: "4.1_WGCNA"
output: html_notebook
---

```{r}
### INSTALLING PACKAGES ###
#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install(c("readr", "tidyverse", "org.At.tair.db", "pathview","dplyr"))

# Clean environment
rm(list = ls(all.names = TRUE)) # will clear all objects including hidden objects
gc() # free up memory and report the memory usage
#set options
options(max.print = .Machine$integer.max, scipen = 0, stringsAsFactors = F, dplyr.summarise.inform = F) # avoid truncated output in R console and keep scientific notation

setwd("~/Desktop/Lab/Working_Projects/trapseq_2023")
suppressPackageStartupMessages({
  library(org.At.tair.db)
  library(DESeq2)
  library(clusterProfiler) #A universal enrichment tool for interpreting omics data #prettydoc?
  library(readr)
  library(tidyverse) #to use distinct in line 52
  library(pathview)
  library(enrichplot)
  library(dplyr)
  library(tibble)
  library(magrittr)
  library(WGCNA)
})
```


```{r}
#Read file
countData<- read_csv("degDESeqDataSetFromMatrix.csv")
countData.df <- data.frame(countData, row.names = countData$...1 )

#rename first column
names(countData.df)[1] = "GeneId"

 cols(
   .default = col_double(),
   Count = col_character()
 )
#countData.df[1:5,1:10]        # Look at first 5 rows and 10 columns
#str(data)           # str = structure of data, useful for debugging data type mismatch errors

# Pivot the data to long format for analysis
mdata <- countData.df %>%
  tidyr::pivot_longer(
    cols = -GeneId
  ) %>%
  mutate(group = gsub("-.*", "", name) %>% gsub("[.].*", "", .))


# order the groups in the plot.
mdata$group = factor(mdata$group, 
                     levels = c("H","IM", "UM"))  
summary(mdata$group)
```

violin plots provide a visual summary of the distribution of the RNA Seq counts for each treatment group, showing the central tendency, spread, and shape of the data distribution
```{r}
# ==== Plot groups (Sample Groups vs RNA Seq Counts) to identify outliers
(
 p <- mdata %>%
    ggplot(., aes(x = name, y = value)) +             # x = treatment, y = RNA Seq count
    geom_violin() +                                   # violin plot, show distribution
    geom_point(alpha = 0.2) +                         # scatter plot
    theme_bw() +
    theme(
      axis.text.x = element_text(angle = 90)          # Rotate treatment text
    ) +
    labs(x = "Treatment Groups", y = "RNA Seq Counts") +
    facet_grid(cols = vars(group), drop = TRUE, scales = "free_x") # Update 'cols' to 'group'
)

# Check 'de_input' matrix
de_input = as.matrix(countData.df[,-1])
row.names(de_input) = countData.df$GeneId
de_input[1:5,1:10]
#str(de_input)

# Create metadata dataframe
meta_df <- data.frame( Sample = names(countData.df[-1])) %>%
  mutate(
    Type = gsub("-.*","", Sample) %>% gsub("[.].*","", .)
  )

# Create DESeqDataSet object
dds <- DESeqDataSetFromMatrix(de_input,
                              meta_df,
                              design = ~Type)
print(dds)
```


```{r}
library(magrittr)
#prefiltering
dds <- (dds[ rowSums( counts(dds) ) > 10 , ])
dds<-DESeq(dds)

#variance stabilization
vsd <- vst(dds, blind = TRUE )

#assign sample names as column names
colnames(vsd)<- meta_df$Sample

#transpose the data matrix, Prepare data for module analysis
datExpr <- assay(vsd) %>%
  t()  

#assign sample names as a row names.'datExpr' data frame containing the expression data, columns corresponding to genes and rows to samples
rownames(datExpr) = colnames(vsd)

#view(datExpr)
```

 
 This code snippet sets up and executes the process of selecting an appropriate soft threshold for weighted network analysis. It uses the pickSoftThreshold function to choose the soft threshold, considering different powers. The resulting soft threshold is then used for further analysis in constructing the weighted network. The code also includes comments to explain each step and the purpose of the plots.
 
 In the context of WGCNA (Weighted Gene Co-Expression Network Analysis), correlation refers to the measure of association or similarity between two genes' expression profiles across different samples.

In WGCNA, genes with highly correlated expression profiles are grouped into modules, which represent sets of genes that tend to be co-expressed under certain conditions or in specific tissues. The correlation between genes is used to construct a network where nodes represent genes and edges (connections) represent the strength of the correlation between genes.

The type of correlation used can impact the results of WGCNA. The default correlation method in WGCNA is Pearson correlation, which measures the linear relationship between two variables (genes in this case). However, Pearson correlation may not capture non-linear relationships or be robust to outliers.

In the context of choosing the soft threshold in WGCNA, using different correlation methods (such as bicor) allows for the exploration of different types of relationships between genes, which can be useful when the data has non-linear relationships or contains outliers.
```{r}
# Define a vector of powers for soft thresholding
powers = c(c(1:10), seq(from = 12, to=20, by=2))

# Choose soft threshold using the pickSoftThreshold function
# This function helps to select an appropriate soft threshold for the weighted network
sft = pickSoftThreshold(datExpr, 
                        powerVector = powers, 
                        verbose = 5)

# Choose soft threshold with bicor correlation, more robust correlation measure
sft = pickSoftThreshold(datExpr,
                        corFnc = "bicor", 
                        corOptions=list(maxPOutliers=0.1),
                        networkType = "signed hybrid", 
                        powerVector = powers, 
                        verbose = 5)

# Set up the plotting window for the following plots
sizeGrWindow(12, 9)
par(mfrow = c(1,2)) # Set the layout of plots to 1 row and 2 columns
cex1 = 0.9 # Set the size of text in plots

# Plot scale independence
plot(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     xlab = "Soft Threshold (power)",
     ylab = "Scale Free Topology Model Fit, signed R^2",
     main = paste("Scale independence")
);
text(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     labels = powers, cex = cex1, col = "red"
);
abline(h = 0.90, col = "red")

# Plot mean connectivity
plot(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     xlab = "Soft Threshold (power)",
     ylab = "Mean Connectivity",
     type = "n",
     main = paste("Mean connectivity")
);
text(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     labels = powers,
     cex = cex1, col = "red")
```


```{r}
# Set the soft thresholding power
softpower = 8

# Perform module detection using blockwiseModules function
nethybrid = blockwiseModules(
  datExpr,                           # Input data (expression matrix)
  power = softpower,                 # Soft thresholding power
  maxBlockSize = 40000,              # Maximum number of genes in each block
  minModuleSize = 30,                # Minimum size of a module
  networkType = "signed hybrid",     # Type of network (signed hybrid)
  TOMType = "signed",                # Type of topological overlap matrix (signed)
  reassignThreshold = 0,             # Threshold for module membership reassignment
  mergeCutHeight = 0.25,             # Height for merging similar modules in the dendrogram
  numericLabels = TRUE,              # Indicates if the sample labels are numeric
  deepSplit = 2,                     # Parameter for hierarchical clustering dendrogram
  pamRespectsDendro = FALSE,         # Determines if the PAM algorithm respects the dendrogram
  saveTOMs = TRUE,                   # Save the topological overlap matrices
  saveTOMFileBase = "ER",            # Base name for saving the topological overlap matrices
  verbose = 5,                       # Level of verbosity for output
  corType = "bicor",                 # Type of correlation calculation
  maxPOutliers = 0.1,                # Maximum proportion of outliers
  pearsonFallback = "individual"     # Fallback method in case bicor fails
)

```

In the context of your code, the cor_significance vector represents the significance of the correlation between module eigengenes for each module. When you calculate the correlation between module eigengenes using cor(datME, use="p"), you get a matrix of correlation values. The signif(..., 2) function is used to round these correlation values to two decimal places.

If a correlation value is not available or meaningful (e.g., due to insufficient variation in the data), the cor_significance vector will contain NA for that particular module. This can happen when the expression of genes within a module does not vary much across samples, making the correlation calculation less informative or impossible. The replacement of NA values with "Insufficient Variation" in the plot titles helps to indicate to the reader that the correlation significance could not be calculated for those modules.
```{r}
# Create a table of module colors
table(nethybrid$colors)

# Set plot window size
sizeGrWindow(12, 9)

# Merge module colors
mergedColors = labels2colors(nethybrid$colors)
#print(mergedColors)

# Plot dendrogram and module colors
plotDendroAndColors(
  nethybrid$dendrograms[[1]],             # Dendrogram to plot
  mergedColors[nethybrid$blockGenes[[1]]],# Module colors
  dendroLabels = FALSE,                   # Hide dendrogram labels
  hang = 0.03,                            # Hang parameter for dendrogram
  addGuide = TRUE,                        # Add color legend
  guideHang = 0.05                        # Hang parameter for color legend
)

# Calculate module eigengenes
datME=moduleEigengenes(datExpr,nethybrid$colors)$eigengenes

# Calculate significance of correlation between module eigengenes
cor_significance = signif(cor(datME, use="p"), 2)
# Replace NA values with a message
cor_significance[is.na(cor_significance)] <- "Insufficient Variation"

# Calculate dissimilarity matrix of module eigengenes
dissimME=(1-t(cor(datME, method="p")))/2

# Perform hierarchical clustering on the module eigengenes
hclustdatME=hclust(as.dist(dissimME), method="average" )


# Set plot window size
par(mfrow=c(1,1))
plot(hclustdatME, main="Clustering tree based of the module eigengenes")

```

```{r}
# Set plot window size
sizeGrWindow(8,9)
par(mfrow=c(3,1), mar=c(1, 2, 4, 1))
modules_to_plot <- c("turquoise", "blue", "brown")
for (which.module in modules_to_plot) {
  plotMat(
    t(scale(datExpr[,mergedColors==which.module ]) ),
    nrgcols=30,
    rlabels=T,
    clabels=T,
    rcols=which.module,
    title=paste("Module Expression Patterns for Module", which.module, ", Correlation Significance:", cor_significance[which.module])
  )
}
```




```{r}
# Get Module Eigengenes per cluster
MEs0 <- moduleEigengenes(datExpr, mergedColors)$eigengenes

# Reorder modules so similar modules are next to each other
MEs0 <- orderMEs(MEs0)
module_order = names(MEs0) %>% gsub("ME","", .)

# Add treatment names
MEs0$treatment = row.names(MEs0)

# tidy & plot data
mME = MEs0 %>%
  pivot_longer(-treatment) %>%
  mutate(
    name = gsub("ME", "", name),
    name = factor(name, levels = module_order)
  )

mME %>% ggplot(., aes(x=treatment, y=name, fill=value)) +
  geom_tile() +
  theme_bw() +
  scale_fill_gradient2(
    low = "blue",
    high = "red",
    mid = "white",
    midpoint = 0,
    limit = c(-1,1)) +
  theme(axis.text.x = element_text( size = 15, angle = 90), axis.title=element_text(size=15)) + labs(title = "Module-trait Relationships", y = "Modules", fill="corr")
#ggsave("module_trait_relationships.png",width=16, height =16) 

#Looking at the heatmap, the green seems positively associated (red shading) with the L groups, turquoise module is positive for the L but negative (blue shading) for the L_L1 groups, and tan module is positive in the S groups but negative elsewhere. There are other patterns, think about what the patterns mean. For this tutorial we will focus on the green, turquoise, and tan module genes.
```

```{r}
# Create a data frame with gene IDs and module colors
module_df <- data.frame(
  gene_id = names(nethybrid$colors),
  colors = labels2colors(nethybrid$colors)
)
# Set row names of module_df to gene_id
row.names(module_df) = module_df$gene_id

# pick out a few modules of interest here
modules_of_interest = c("turquoise", "yellow","brown")

# Pull out list of genes in that module
submod <- module_df %>%
  filter(colors %in% modules_of_interest)


# Convert gene_id to match the format of row names in datExpr
missing_genes <- setdiff(submod$gene_id, row.names(vsd))
print(missing_genes)

# Get normalized expression for those genes
subexpr <- datExpr[,submod$gene_id]
# Transpose the subsetted matrix
subexpr_t <- t(subexpr)

# Optionally, assign meaningful row names (sample IDs) and column names (gene IDs)
colnames(subexpr_t) <- colnames(vsd)
rownames(subexpr_t) <- submod$gene_id
#print(subexpr)
```


```{r}
submod_df <- data.frame(subexpr_t) %>%
  mutate(
    gene_id = row.names(.)
  ) %>%
  pivot_longer(-gene_id) %>%
  mutate(
    module = module_df[gene_id, ]$colors
  )

submod_df %>% ggplot(., aes(x = name, y = value, group = gene_id)) +
  geom_line(aes(color = module),
            alpha = 0.2) +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90)
  ) +
  facet_grid(rows = vars(module)) +
  labs(x = "treatment",
       y = "normalized expression")

```

```{r}
# Transpose the countData.df data frame, excluding the first column, to create datExpr0
datExpr0 = as.data.frame(t(countData.df[,-1]))
# Assign the values in the GeneId column of countData.df as the column names of datExpr0
names(datExpr0)=countData.df$GeneId
# Assign the names of the columns of countData.df (excluding the first column) as row names of datExpr0
rownames(datExpr0)=names(countData.df)[-1]
datExpr0[] = lapply(datExpr0, as.numeric)

#checking for the missing values and remotion of NA
gsg = goodSamplesGenes(datExpr0, verbose = 3);
gsg$allOK
#if it is not
if (!gsg$allOK)
{
  # Optionally, print the gene and sample names that were removed:
  if (sum(!gsg$goodGenes)>0)
    printFlush(paste("Removing genes:", paste(names(datExpr0)[!gsg$goodGenes], collapse = ", ")));
  if (sum(!gsg$goodSamples)>0)
    printFlush(paste("Removing samples:", paste(rownames(datExpr0)[!gsg$goodSamples], collapse = ", ")));
  # Remove the offending genes and samples from the data:
  datExpr0 = datExpr0[gsg$goodSamples, gsg$goodGenes]
}
```


```{r}
# Choose a soft threshold power- USE A SUPERCOMPUTER IRL ------------------------------------
powers = c(c(1:10), seq(from =10, to=30, by=1)) #choosing a set of soft-thresholding powers
sft = pickSoftThreshold(datExpr0, powerVector=powers, verbose =5, networkType="signed") #call network topology analysis function
sizeGrWindow(9,5)
par(mfrow= c(1,2))
cex1=0.9
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2], xlab= "Soft Threshold (power)", ylab="
Scale Free Topology Model Fit, signed R^2", type= "n", main= paste("Scale independence"))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2], labels=powers, cex=cex1, col="red")
abline(h=0.90, col="red")
plot(sft$fitIndices[,1], sft$fitIndices[,5], xlab= "Soft Threshold (power)", ylab="Mean Connectivity", type="n", main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1, col="red")
#from this plot, we
```


```{r}
softpower = 8
sampleTree = hclust(dist(datExpr), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
sizeGrWindow(12,9)
#pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,
     cex.axis = 1.5, cex.main = 2)
# Plot a line to show the cut
abline(h = 355, col = "red");
# Determine cluster under the line
clust = cutreeStatic(sampleTree, cutHeight = 355, minSize = 10)
table(clust)
# clust 1 contains the samples we want to keep.
keepSamples = (clust==1)
datExpr = datExpr[keepSamples, ]
nGenes = ncol(datExpr)
nSamples = nrow(datExpr)
```


```{r}
#how to detect outliers
library(rrcov)
pcaHub = PcaHubert(datExpr)
outliers = which(pcaHub@flag =="FALSE")

# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=20, by=2))

# Call the network topology analysis function
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)

# Plot the results:
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")

# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")

net = blockwiseModules(datExpr, power = 20,
                       TOMType = "unsigned", maxBlockSize = 30000, minModuleSize = 30,
                       reassignThreshold = 0, mergeCutHeight = 0.89,
                       numericLabels = TRUE, pamRespectsDendro = FALSE,
                       saveTOMs = TRUE,
                       saveTOMFileBase = "spimp_TOM",
                      verbose = 3)

table(nethybrid$colors)
# open a graphics window
sizeGrWindow(12, 9)
# Convert labels to colors for plotting
mergedColors = labels2colors(net$colors)
# Plot the dendrogram and the module colors underneath
plotDendroAndColors(net$dendrograms[[1]], mergedColors[net$blockGenes[[1]]],
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)
```


```{r}
# Create a data frame with gene IDs and module colors
module_df <- data.frame(
  gene_id = names(nethybrid$colors),
  colors = labels2colors(nethybrid$colors)
)

#module assignment
#moduleLabels = nethybrid$colors
#moduleColors = labels2colors(nethybrid$colors)

meta_df <- data.frame( Sample = names(countData.df[-1])) %>%
  mutate(
    Type = gsub("-.*","", Sample) %>% gsub("[.].*","", .)
  )

#module eigengene
MEs = nethybrid$MEs
geneTree = nethybrid$dendrograms[[1]]


#traitData=read.csv("jh_metadata.csv")

metaSamples = rownames(datExpr0);
traitRows = match(metaSamples, meta_df$Sample);
#traitRows

datTraits = meta_df[traitRows, -1];
rownames(datTraits) = meta_df[traitRows, 1];
datTraits[] = lapply(datTraits, as.numeric)
```


```{r}
# Re-cluster samples
sampleTree2 = hclust(dist(datExpr), method = "average")
# Convert traits to a color representation: white means low, red means high, grey means missing entry
traitColors = numbers2colors(datTraits, signed = FALSE);
# Plot the sample dendrogram and the colors underneath.
plotDendroAndColors(sampleTree2, traitColors,
                    groupLabels = names(datTraits),
                    main = "Sample dendrogram and trait heatmap")

names(datExpr0)


# Define numbers of genes and samples
nGenes = ncol(datExpr);
nSamples = nrow(datExpr);
# Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr, moduleColors)$eigengenes
MEs = orderMEs(MEs0)
moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);

sizeGrWindow(10,6)
# Will display correlations and their p-values
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                   signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)
par(mar = c(6, 8.5, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = names(datTraits),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = greenWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module-trait relationships"))

#=====================================================================================
#
#  Code chunk 4
#
#=====================================================================================


# Define variable weight containing the weight column of datTrait
iron = as.data.frame(datTraits$DPI);
names(dpi) = "Dpi"
# names (colors) of the modules
modNames = substring(names(MEs), 3)

geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"));
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples));

names(geneModuleMembership) = paste("MM", modNames, sep="");
names(MMPvalue) = paste("p.MM", modNames, sep="");

geneTraitSignificance = as.data.frame(cor(datExpr, iron, use = "p"));
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples));

names(geneTraitSignificance) = paste("GS.", names(iron), sep="");
names(GSPvalue) = paste("p.GS.", names(iron), sep="");


#=====================================================================================
#
#  Code chunk 5
#
#=====================================================================================


module = "lightcyan"
column = match(module, modNames);
moduleGenes = moduleColors==module;

sizeGrWindow(7, 7);
par(mfrow = c(1,1));
verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
                   abs(geneTraitSignificance[moduleGenes, 1]),
                   xlab = paste("Module Membership in", module, "module"),
                   ylab = "Gene significance for body weight",
                   main = paste("Module membership vs. gene significance\n"),
                   cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module, )


#=====================================================================================
#
#  Code chunk 6
#
#=====================================================================================


names(datExpr)


#=====================================================================================
#
#  Code chunk 7
#
#=====================================================================================


iron_name=names(datExpr)[moduleColors=="lightcyan"]
write(iron_name, file ="iron_names.txt", sep = "\t")

#=====================================================================================
#
#  Code chunk 8
#
#=====================================================================================


annot = read.csv(file = "GeneAnnotation.csv");
dim(annot)
names(annot)
probes = names(datExpr)
probes2annot = match(probes, annot$substanceBXH)
# The following is the number or probes without annotation:
sum(is.na(probes2annot))
# Should return 0.


#=====================================================================================
#
#  Code chunk 9
#
#=====================================================================================


# Create the starting data frame
geneInfo0 = data.frame(substanceBXH = probes,
                       geneSymbol = annot$gene_symbol[probes2annot],
                       LocusLinkID = annot$LocusLinkID[probes2annot],
                       moduleColor = moduleColors,
                       geneTraitSignificance,
                       GSPvalue)
# Order modules by their significance for weight
modOrder = order(-abs(cor(MEs, weight, use = "p")));
# Add module membership information in the chosen order
for (mod in 1:ncol(geneModuleMembership))
{
  oldNames = names(geneInfo0)
  geneInfo0 = data.frame(geneInfo0, geneModuleMembership[, modOrder[mod]], 
                         MMPvalue[, modOrder[mod]]);
  names(geneInfo0) = c(oldNames, paste("MM.", modNames[modOrder[mod]], sep=""),
                       paste("p.MM.", modNames[modOrder[mod]], sep=""))
}
# Order the genes in the geneInfo variable first by module color, then by geneTraitSignificance
geneOrder = order(geneInfo0$moduleColor, -abs(geneInfo0$GS.weight));
geneInfo = geneInfo0[geneOrder, ]




TOM = TOMsimilarityFromExpr(datExpr, power = 6);
modules = c("brown", "lightcyan");
probes = names(datExpr)
inModule = is.finite(match(moduleColors, modules));
modProbes = probes[inModule];

modTOM = TOM[inModule, inModule];
dimnames(modTOM) = list(modProbes, modProbes)
cyt = exportNetworkToCytoscape(modTOM,
                               edgeFile = paste("CytoscapeInput-edges-", paste(modules, collapse="-"), ".txt", sep=""),
                               nodeFile = paste("CytoscapeInput-nodes-", paste(modules, collapse="-"), ".txt", sep=""),
                               weighted = TRUE,
                               threshold = 0.05,
                               nodeNames = modProbes,
                               altNodeNames = modProbes,
                               nodeAttr = moduleColors[inModule]);




```

