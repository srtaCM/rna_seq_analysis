---
title: "2_DEG_Analysis.Rmd"
output: html_notebook
---

# ICM 2024FEB6 DESeq2 Script

# UM v IM v H
---
title: "1_diagnostics_andDEGs_Notebook"
output: html_notebook
---
# ICM 2024FEB6 DESeq2 Script

# UM v IM v H

```{r CODE CHUNK 1 INSTALLING ALL PROGRAMS}
#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install(c("circlize", "corrplot", "dendextend","readr","DESeq2","vsn", "ggfortify", "ggrepel", "ggplot2", "pheatmap", "devtools", "ggforce","pheatmap", "gplots", "RColorBrewer", "ggdendro", "magrittr","apeglm","dplyr","tibble","VennDiagram","limma")) 


```

```{r CODE CHUNK 2 DATA SET UP}

#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install(c("circlize", "corrplot", "dendextend","readr","DESeq2","vsn", "ggfortify", "ggrepel", "ggplot2", "pheatmap", "devtools", "ggforce","pheatmap", "gplots", "RColorBrewer", "ggdendro", "magrittr","apeglm"))

######CHANGE THIS
setwd("~/Desktop/Lab/Working_Projects/trapseq_2023")


library(readr)
featcount <- read_table("featcount.txt", 
                        col_names = TRUE, skip = 1)
read.count <- data.frame(featcount, row.names = featcount$Geneid ) #gene ids stored as row names
geneID<- featcount$Geneid

read.count <- read.count [ ,-c(1:6)] #removes the columns without gene counts not the same as bottom row code

orig_names <- names(read.count)
#print(orig_names)

colnames(read.count) <- (c("IT-107","IT-108", "IT-109", "IT-110", "H-107", "H-108", "H-109", "H-110","H-111", "UT-106", "UT-108", "UT-114", "IT-206", "IT-207", "IT-208", "IT-209", "IM-206", "IM-207", "IM-208", "IM-209", "IM-210", "UT-204", "UT-208", "UT-213", "UT-214", "UM-204", "UM-208", "UM-213", "UM-214", "UM-215")) 
#view(read.count)


ImvHvUM <- read.count [ ,-c(1:4, 10:16,22:25)]

sample_info <- data.frame(
  sample = c( "H-107", "H-108", "H-109", "H-110","H-111","IM-206", "IM-207", "IM-208", "IM-209", "IM-210","UM-204", "UM-208", "UM-213", "UM-214", "UM-215" ),
  groups=c( "H", "H", "H", "H","H", "IM", "IM", "IM", "IM", "IM","UM","UM","UM","UM","UM"),
  condition =c("Infected","Infected","Infected","Infected","Infected","Infected","Infected","Infected","Infected","Infected", "Uninfected","Uninfected","Uninfected","Uninfected","Uninfected"),
  replicate= c("H-107", "H-108", "H-109", "H-110","H-111", "IM-206", "IM-207", "IM-208", "IM-209", "IM-210","UM-204", "UM-208", "UM-213", "UM-214", "UM-215"),
  row.names = "sample") 


metadata <- as.data.frame.array(sample_info)

all(rownames(metadata) %in% colnames(ImvHvUM))


sample_info$groups<- as.factor(sample_info$groups)
all(rownames(sample_info) %in% colnames(ImvHvUM)) #if false something is wrong
sample_info 
```


```{r CODE CHUNK 3 DESEQ MATRIX}
suppressPackageStartupMessages(library(DESeq2))

dds <- DESeqDataSetFromMatrix(countData = ImvHvUM,
                              colData = sample_info,
                              design = ~groups)
print(dds)

library(magrittr)
#prefiltering, removing genes with less than 10 counts
dds <- (dds[ rowSums( counts(dds) ) > 10 , ])

#set comparison against control/mock
dds$groups<-relevel(dds$groups, ref = "UM")
dds$groups

#summary(dds$groups)

```



```{r CODE CHUNK 4 DIAGNOSTICS VST NORMALIZATION}
#VST is separate and can be used for visualization, clustering or other ML (machine learning) tasks

library(vsn)

vsd <- vst(dds, blind = TRUE )
```

#with plotpca i CAN use rld as is
```{r CODE CHUNK 5 DIAGNOSTICS PCA}
# PCA principle component analysis, visualize the similarities and differences between *samples*
library(gplots) 
library(RColorBrewer)
library(corrplot)
library(ggdendro)
library(magrittr)
library(dendextend)
library(ggplot2)
library(ggrepel)

#USING TOP 5000 genes
pcadata<- plotPCA(vsd, intgroup=c("replicate","groups"), ntop=5000, returnData = TRUE) 
summary(pcadata)

percentVar <- round(100 * attr(pcadata, "percentVar"))

p <- ggplot(pcadata, aes(PC1,PC2, label = replicate, colour = groups )) +
  geom_point(aes(shape=groups),size=3) + scale_color_manual(values = c("#FF1BB3","#E5751F","#861F41")) + 
   theme_classic()


p2 <- p + geom_text_repel(box.padding = 0.5, max.overlaps = 15, segment.linetype = 2) + labs(title = "normalized counts") +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance"))
p2
#ggsave("PCA_5000.png") 
#saved as of 2.06.2024



``````

######Pairwise correlation cor()
#The Pearson correlation coefficient, r, is a measure of the strength of the linear relationship between two variables and is often used to assess the similarity of RNA-seq samples in a pair-wise fashion. It is defined as the covariance of two variables divided by the product of their standard deviation. 


######Hierarchical clustering
#To determine whether the different sample types can be separated in an unsupervised fashion (i.e., samples of different conditions are more dissimilar to each other than replicates within the same condition) Hierarchical clustering is typically based on pairwise comparisons of individual samples, which are grouped into “neighborhoods" of similar samples. The basis of hierarchical clustering is therefore a matrix of similarity metrics (which is different from the actual gene expression values!).
#Hierarchical clustering requires two decisions:
#  1. How should the (dis)similarity between pairs be calculated? 
#  2. How should the (dis)similarity be used for the clustering?
#A common way to assess the (dis)similarity is the Pearson correlation coefficient, r, that we just described. The corresponding distance measure is d = 1 − r. 

#Decide on how the distances should be used to define clusters of samples. The most popular choices for the linkage function are
# complete: intercluster distance ≡ largest distance between any 2 members of either cluster 
# average: intercluster distance ≡ average distance between any 2 members
# single: intercluster distance ≡ shortest distance between any 2 members

#pearson is the default, complete is best

MA plot MA plots were originally developed for microarray visualization, but they are also useful for RNA-seq analyses. The MA plot provides a global view of the relationship between the expression change between conditions (log ratios, M), the average expression strength of the genes (average mean, A) and the ability of the algorithm to detect differential gene expression: genes that pass the significance threshold (adjusted p-value) are colored in red


```{r CODE CHUNK 6 DISTANCE MATRIX AND HEAT MAPS}
library(gplots) 
library(RColorBrewer)
library(corrplot)
library(ggdendro)
library(magrittr)
library(dendextend)
library(pheatmap)
library(dplyr)

#making the distance matrix
# obtain regularized log - transformed values
norm.counts <- assay(vsd)

# cor () calculates the correlation between columns of a matrix
distance.m <- as.dist (1 - cor( norm.counts , method = "pearson" ))

# plot () the output of hclust ()
hc<- hclust(distance.m)
hcd<-as.dendrogram(hc)

hcd <- hcd %>% 
  color_branches(k = 3)

plot(hcd,
     type = "rectangle", ylab = "Height",
     main = " vst transformed read counts \n distance : Pearson correlation ") 
#dev.copy2pdf(file="Distancedend.pdf")
#saved as of 11.26.2023



#Hclust HeatMap
DistMatrix <- as.matrix(distance.m)
rownames(DistMatrix) <- paste(vsd$replicate,  sep="-" )
colnames(DistMatrix)<-paste(vsd$replicate,  sep="-" )


#color scheme
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)

#generate heat map
pheatmap(DistMatrix,
         clustering_distance_rows=distance.m,
         clustering_distance_cols=distance.m,
         col=colors)
#dev.copy2pdf(file="Distancematrix.pdf")
#saved as of 11.26.2023


topVarGenes<-head(order(rowVars(assay(vsd)),decreasing=TRUE),5000)
pheatmap(assay(vsd)[topVarGenes,],scale="row", cutree_cols=2, show_rownames = FALSE,fontsize=11, col=colorRampPalette(rev(brewer.pal(9,"RdBu")))(255))
#dev.copy2pdf(file="25_topexpressed.pdf")
#saved as of 1.22.2024
``````{r CODE CHUNK 7 DESEQ AND RESULTS}
library(DESeq2)
library(dplyr)
library(tibble)

dds.ds <-DESeq(dds)
res<-results(dds.ds, tidy=TRUE) %>%
  column_to_rownames(var="row") %>%  
  write_csv("de_analysis_DESeq_all.csv")
```


```{r CODE CHUNK 8 FILTERING DEG}
res05 <- results(dds.ds, 
                 independentFiltering = TRUE,
                 alpha = 0.05)
#write_csv("results_05backup_DESeq_all.csv") #still have to write it to csv #fix this

 res05 %>%
   as.data.frame() %>%
   filter(padj < 0.05) %>%
   arrange(desc(padj)) # %>% write.csv("de_analysis_DESeq_sig05.csv")
#saveRDS(dds.ds, file="RobjectsDE.rds")


dds.ds$groups #check levels
#set reference level 
#dds.ds$groups<-relevel(dds.ds$groups, ref = "UM")

summary(res05)
```


```{r CODE CHUNK 8  DEG}
#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install(c("AnnotationDbi", "org.At.tair.db", "pathview", "gageData"))

library(AnnotationDbi)
library(org.At.tair.db)
class(org.At.tair.db)
columns(org.At.tair.db)

#print(res05)

res05$symbol = mapIds(org.At.tair.db, 
                    keys= row.names(res05), 
                    keytype= "TAIR" , 
                    column= "SYMBOL", 
                    multiVals= "first")

res05$entrez = mapIds(org.At.tair.db, 
                    keys=row.names(res05), 
                    keytype="TAIR", 
                    column="ENTREZID", 
                    multiVals="first")



res05 %>%
   as.data.frame() %>%
   filter(padj < 0.05) %>%
   arrange(desc(padj)) %>% write.csv("de_analysis_DESeq_sig05.csv") 
print(res05) 
``````{r CODE CHUNK 9 DEG}
#to see how many genes are < to 0.05
table(res05$padj<0.05) 
print(res05)


library(tibble)
diff_genes = res05 %>% 
  as.data.frame() %>%
  rownames_to_column(var="genes")  #%>% write.csv("DEG_sig05.csv")
#head(diff_genes)

#sum(diff_genes$pvalue < 0.05, na.rm=TRUE)

#sum(!is.na(diff_genes$pvalue))

#sum(diff_genes$padj < 0.05, na.rm=TRUE)
``````{r CODE CHUNK 10 READ IN DEG DOC}
diff_genes<- read_delim(file="DEG_sig05.csv", delim = ",")
nrow(diff_genes)
```


```{r CODE CHUNK 11 Filtering DEG}
#diff_genes %>% 
#  filter(log2FoldChange > 0) %>% 
#  with(.,quantile(log2FoldChange, c(0.5,0.75,0.9)))

#diff_genes %>% 
#  filter(log2FoldChange > quantile(log2FoldChange, c(0.75))) %>% # keeping fold changes above the 75th percentile
#  dplyr::select(genes) #%>% write.table(., file = "diff_genes_for_test.tsv", row.names = FALSE, quote = FALSE)


```

```{r VENN DIAGRAM}
#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install(c("VennDiagram"))

library(VennDiagram)

UMVsIM<-results(dds.ds,c('groups', 'IM', 'UM'))

UMvsH<-results(dds.ds,c("groups","H","UM"))

#UMvsH

IM_DF<-as.data.frame(UMVsIM)
#table(IM_DF$padj<0.05) # FALSE 10639 TRUE 11390

H_DF<-as.data.frame(UMvsH)
#table(H_DF$padj<0.05) #FALSE 8199 TRUE 13830 

IM_DF<-IM_DF[!is.na(IM_DF$padj), ]
H_DF<-H_DF[!is.na(H_DF$padj), ]


IM_DF<-IM_DF[,c("log2FoldChange","padj")]
H_DF<-H_DF[,c("log2FoldChange","padj")]

colnames(IM_DF)<-paste0("UMVsIM","_",colnames(IM_DF))
colnames(H_DF)<-paste0("UMVsH","_",colnames(H_DF))
fullTable<-merge(IM_DF, H_DF, by = 0)
fullTable[1:2, ]
```


```{r VENN DIAGRAM im results}
#UPIMUM <-c(fullTable$UMVsIM_log2FoldChange > 1 & fullTable$UMVsIM_padj < 0.05) 
#upIMTable<-fullTable[UPIMUM, ]
#upIMTable

#IMup2500 = upIMTable[1:2500, ] %>% 
#  as.data.frame() 
#IMup2500 %>% 
#  dplyr::select(Row.names) #%>% write.table(., file = "IMreg2500.tsv", row.names = FALSE, quote = FALSE)
```


```{r VENN DIAGRAM up results}
upIMH<-fullTable$UMVsIM_log2FoldChange > 1 & fullTable$UMVsH_log2FoldChange > 1 & fullTable$UMVsIM_padj < 0.05 & fullTable$UMVsH_padj < 0.05
upIMHTable<-fullTable[upIMH, ]
upIMHTable

#up2500 = upIMHTable[1:2500, ] %>% 
#  as.data.frame() 
#up2500 %>% 
#  dplyr::select(Row.names) #%>% write.table(., file = "IMHreg2500.tsv", row.names = FALSE, quote = FALSE)
#head(up2500)


forVenn<-data.frame(UpIM=fullTable$UMVsIM_log2FoldChange > 1 & fullTable$UMVsIM_padj < 0.05, UpH=fullTable$UMVsH_log2FoldChange > 1 & fullTable$UMVsH_padj < 0.05) 
forVenn #[1:3, ]
table(forVenn)


library(limma)
vennDiagram(forVenn, circle.col =c("#861F41", "#E5751F"))
#dev.copy2pdf(file="upvenn0.05lfc1.pdf")


```


```{r}
dwnIMH<-fullTable$UMVsIM_log2FoldChange < 1 & fullTable$UMVsH_log2FoldChange < 1 & fullTable$UMVsIM_padj < 0.05 & fullTable$UMVsH_padj < 0.05
dwnIMHTable<-fullTable[dwnIMH, ]
#dwnIMHTable

down2500 = dwnIMHTable[1:2500, ] %>% 
  as.data.frame()
down2500 %>% 
  dplyr::select(Row.names) #%>% write.table(., file = "downreg2500.tsv", row.names = FALSE, quote = FALSE)
#head(down2500)


forVenn2<-data.frame(DwnIM=fullTable$UMVsIM_log2FoldChange < 1 & fullTable$UMVsIM_padj < 0.05 , DwnH=fullTable$UMVsH_log2FoldChange < 1 & fullTable$UMVsH_padj < 0.05)
forVenn2 #[1:3, ]
view(forVenn2)




library(limma)
vennDiagram(forVenn2, circle.col =c("#861F41", "#E5751F"))
dev.copy2pdf(file="dwnvenn0.05lfc1.pdf")
```


```{r}
#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install(c("AnnotationDbi", "org.At.tair.db", "pathview", "gageData"))

library(AnnotationDbi)
library(org.At.tair.db)
class(org.At.tair.db)
columns(org.At.tair.db)

print(res05)

res05$symbol = mapIds(org.At.tair.db, 
                    keys= row.names(res05), 
                    keytype= "TAIR" , 
                    column= "SYMBOL", 
                    multiVals= "first")

res05$entrez = mapIds(org.At.tair.db, 
                    keys=row.names(res05), 
                    keytype="TAIR", 
                    column="ENTREZID", 
                    multiVals="first")


head(res05,10)
```



```{r}
setwd("~/Desktop/Lab/Working_Projects/trapseq_2023")
#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install(c("AnnotationDbi", "org.At.tair.db", "pathview", "gageData"))

library(AnnotationDbi)
library(org.At.tair.db)
class(org.At.tair.db)
columns(org.At.tair.db)

print(res)

res$symbol = mapIds(org.At.tair.db, 
                    keys= row.names(res), 
                    keytype= "TAIR" , 
                    column= "SYMBOL", 
                    multiVals= "first")

res$entrez = mapIds(org.At.tair.db, 
                    keys=row.names(res), 
                    keytype="TAIR", 
                    column="ENTREZID", 
                    multiVals="first")


head(res,10)
```resOrdered <-res[order(res$pvalue),]
head(resOrdered)
resOrderedDF <-as.data.frame(resOrdered)[1:100, ]
write.csv(resOrderedDF,file ="results.csv")
library(pathview)
library(gageData)
data(kegg.sets.hs)
data(sigmet.idx.hs)
# Focus on signaling and metabolic pathways only
kegg.sets.hs =kegg.sets.hs[sigmet.idx.hs]
# Examine the first 3 pathways
head(kegg.sets.hs,3)

```#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install(c("biomartr", "clusterProfiler","tidyverse","enrichplot","biomaRt"))

library("biomartr")
library("clusterProfiler")
library("tidyverse")
library("enrichplot")
suppressPackageStartupMessages(library("org.At.tair.db"))
library("biomaRt")  # only use to remove cache bug

listMarts()
#ensembl=useMart(biomart, dataset = "athaliana_eg_gene")
#listDatasets(ensembl)
#listEnsemblGenomes()
#listEnsembl()nsembl_plants <- useEnsemblGenomes(biomart = "plants_mart")
searchDatasets(ensembl_plants, pattern = "Arabidopsis")
ensembl_arabidopsis <- useEnsemblGenomes(biomart = "plants_mart", 
                                         dataset = "athaliana_eg_gene")

listMarts(host="plants.ensembl.org")
mart <- useMart("plants_mart",  host = "https://plants.ensembl.org")
head(listDatasets(mart))


#ensembl = useEnsembl(biomart="plants_mart")
head(listFilters(ensembl_arabidopsis))
```#biomartr::organismBM(organism = "Arabidopsis thaliana")
#arabido_attributes = 
#  biomartr::organismAttributes("Arabidopsis thaliana") %>% 
#  filter(dataset == "athaliana_eg_gene")
#arabido_attributes

#attributes_to_retrieve = c("tair_symbol", "entrezgene_id")

#mart <- useMart("plants_mart", host = "plants.ensembl.org")
#mart <- useMart("plants_mart", "athaliana_eg_gene", host = "plants.ensembl.org")

#grep("go", listAttributes(mart)[,1], value = TRUE)


## ----filters---
filters = head(listFilters(ensembl_arabidopsis))
filters[1:5,]

## ----attributes----
attributes = listAttributes(ensembl_arabidopsis)
attributes[1:5,]
```## ----getBM1, echo=TRUE,eval=TRUE--------
affyids <- c("202763_at","209310_s_at","207500_at")
getBM(attributes = c('ensembl_gene_id', 'description'),
      filters = 'chromosome_name',
      values = affyids, 
      mart = ensembl_arabidopsis)
```


```{r}
## ----searchAttributes, echo = TRUE, eval = TRUE--------
searchAttributes(mart = ensembl_arabidopsis, pattern = "Arabidopsis")

```## ----searchFilters, echo = TRUE, eval = TRUE---------------
searchFilters(mart = ensembl_arabidopsis, pattern = "ensembl.*id")
```## ----filtervalues, fig.cap='The options available to the Chromosome/Scaffold field are limited to a pretermined list based on the values in this dataset.', echo = FALSE----
#knitr::include_graphics('filtervalues.png')

## ----chromosomeNames, results = FALSE--------------
listFilterOptions(mart = ensembl_arabidopsis, filter = "chromosome_name")

## ----listFilterOptions, results = TRUE-----
searchFilterOptions(mart = ensembl_arabidopsis, filter = "chromosome_name", 
                    pattern = "^GL")
searchFilterOptions(mart = ensembl_arabidopsis, filter = "phenotype_description", 
                    pattern = "Crohn")

## ----filterType---------------------
filterType("with_affy_hg_u133_plus_2", ensembl_arabidopsis)

## ----attributePages--------------------
pages = attributePages(ensembl_arabidopsis)
pages

## ----listAttributes--------------------
head(listAttributes(ensembl_arabidopsis, page="feature_page"))

## ----columnsAndKeyTypes-----------------
mart <- useEnsembl(dataset = "hsapiens_gene_ensembl", biomart='ensembl')
head(keytypes(mart), n = 3)
head(columns(mart), n = 3)

## ----keys1-----------------------
k = keys(mart, keytype="chromosome_name")
head(k, n=3)

## ----keys2-----------------------
k = keys(mart, keytype="chromosome_name", pattern="LRG")
head(k, n=3)

## ----select-----------------------
affy=c("202763_at","209310_s_at","207500_at")
select(mart, keys=affy, columns=c('affy_hg_u133_plus_2','entrezgene_id'),
  keytype='affy_hg_u133_plus_2')

## ----cacheInfo---------------------
biomartCacheInfo()

## ----cache-location, echo=1:2---------------
Sys.setenv(BIOMART_CACHE = tempdir())
biomartCacheInfo()
Sys.unsetenv("BIOMART_CACHE")

## ----task1, echo=TRUE,eval=TRUE----------------------
affyids=c("202763_at","209310_s_at","207500_at")
getBM(attributes = c('affy_hg_u133_plus_2', 'hgnc_symbol', 'chromosome_name',
                   'start_position', 'end_position', 'band'),
      filters = 'affy_hg_u133_plus_2', 
      values = affyids, 
      mart = ensembl)

## ----task2, echo=TRUE,eval=TRUE-------------------------
entrez=c("673","837")
goids = getBM(attributes = c('entrezgene_id', 'go_id'), 
              filters = 'entrezgene_id', 
              values = entrez, 
              mart = ensembl)
head(goids)

## ----task3, echo=TRUE,eval=TRUE----------------------
 go=c("GO:0051330","GO:0000080","GO:0000114","GO:0000082")
 chrom=c(17,20,"Y")
 getBM(attributes= "hgnc_symbol",
        filters=c("go","chromosome_name"),
        values=list(go, chrom), mart=ensembl)

## ----task4, echo=TRUE,eval=TRUE---------------------
refseqids = c("NM_005359","NM_000546")
ipro = getBM(attributes=c("refseq_mrna","interpro","interpro_description"), 
             filters="refseq_mrna",
             values=refseqids, 
             mart=ensembl)
ipro

## ----task5, eval = TRUE------------------------------
getBM(attributes = c('affy_hg_u133_plus_2','ensembl_gene_id'), 
      filters = c('chromosome_name','start','end'),
      values = list(16,1100000,1250000), 
      mart = ensembl)

## ----task6, echo=TRUE, eval = TRUE---------------------------------------------
getBM(attributes = c('entrezgene_id','hgnc_symbol'), 
      filters = 'go', 
      values = 'GO:0004707', 
      mart = ensembl)

## ----task7, eval=TRUE-------------------
entrez=c("673","7157","837")
getSequence(id = entrez, 
            type="entrezgene_id",
            seqType="coding_gene_flank",
            upstream=100, 
            mart=ensembl) 

## ----task8, echo=TRUE,eval=TRUE---------
utr5 = getSequence(chromosome=3, start=185514033, end=185535839,
                   type="entrezgene_id",
                   seqType="5utr", 
                   mart=ensembl)
utr5

## ----task9, echo=TRUE, eval=TRUE-----------
protein = getSequence(id=c(100, 5728),
                      type="entrezgene_id",
                      seqType="peptide", 
                      mart=ensembl)
protein

```


```{r}
diff_genes<- read_delim(file="diffgenes_sig05.csv", delim = ",")
nrow(diff_genes)
biomartr::organismBM(organism = "Arabidopsis thaliana")
arabido_attributes = 
  biomartr::organismAttributes("Arabidopsis thaliana") %>% 
  filter(dataset == "athaliana_eg_gene")
arabido_attributes

attributes_to_retrieve = c("tair_symbol", "entrezgene_id")

mart <- useMart("plants_mart", host = "plants.ensembl.org")
mart <- useMart("plants_mart", "athaliana_eg_gene", host = "plants.ensembl.org")
go <- getBM(attributes = c("go_id", "tair_locus", "namespace_1003"), 
            mart=ensembl)
grep("go", listAttributes(mart)[,1], value = TRUE)


result_BM <- biomartr::biomart( 
  genes  = diff_genes$genes,                  
  mart   = plants_mart,                     
  dataset  = athaliana_eg_gene,             
  attributes = attributes_to_retrieve,          
  filters =   ensembl_gene_id )
head(result_BM)  
```

```{r}
# building the universe!
all_arabidopsis_genes <- read.delim("counts.txt", header = T, stringsAsFactors = F)[,1] # directly selects the gene column

# we want the correspondence of TAIR/Ensembl symbols with NCBI Entrez gene ids
attributes_to_retrieve = c("tair_symbol", "uniprotswissprot","entrezgene_id")

# Query the Ensembl API
all_arabidopsis_genes_annotated <- biomartr::biomart(genes = all_arabidopsis_genes,
                                                     mart       = "plants_mart",                 
                                                     dataset    = "athaliana_eg_gene",           
                                                     attributes = attributes_to_retrieve,        
                                                     filters =  "ensembl_gene_id" )  

# for compatibility with enrichGO universe
# genes in the universe need to be characters and not integers (Entrez gene id)
all_arabidopsis_genes_annotated$entrezgene_id = as.character(
  all_arabidopsis_genes_annotated$entrezgene_id) 

# retrieving NCBI Entrez gene id for our genes called differential
diff_arabidopsis_genes_annotated <- biomartr::biomart(
  genes = diff_genes$genes,
  mart       = "plants_mart",                 
                                                     dataset    = "athaliana_eg_gene",           
                                                     attributes = attributes_to_retrieve,        
                                                     filters =  "ensembl_gene_id" ) 

# performing the ORA for Gene Ontology Biological Process class
ora_analysis_bp <- enrichGO(gene = diff_arabidopsis_genes_annotated$entrezgene_id, 
                            universe = all_arabidopsis_genes_annotated$entrezgene_id, 
                            OrgDb = org.At.tair.db,  # contains the TAIR/Ensembl id to GO correspondence for A. thaliana
                            keyType = "ENTREZID",
                            ont = "BP",              # either "BP", "CC" or "MF",
                            pAdjustMethod = "BH",
                            qvalueCutoff = 0.05,
                            readable = TRUE, 
                            pool = FALSE)

```

``````{r}
# universe
universe<- read_delim(file="downreg2500.tsv", delim = ",")
universe<-universe$Row.names

# load  annotation and ID library
library(AnnotationDbi)
library(org.At.tair.db)
class(org.At.tair.db)
columns(org.At.tair.db)

#print(res05)

res05$symbol = mapIds(org.At.tair.db, 
                    keys= row.names(res05), 
                    keytype= "TAIR" , 
                    column= "SYMBOL", 
                    multiVals= "first")

res05$entrez = mapIds(org.At.tair.db, 
                    keys=row.names(res05), 
                    keytype="TAIR", 
                    column="ENTREZID", 
                    multiVals="first")

# convert gene names to Entrez ID
genemap <- select(AnnotationDb, selected, "ENTREZID", "SYMBOL")
univmap <- select(org.At.tair.db, universe, "ENTREZID", "SYMBOL")

# load GO scoring package
biocLite(“GOstats”)
library(GOstats)
# set up analysis
param<- new ("GOHyperGParams", geneIds = genemap, universeGeneIds=univmap, annotation="org.Mm.eg.db",
ontology="BP",pvalueCutoff=0.01, conditional=FALSE, testDirection="over")
# run analysis
hyp<-hyperGTest(param)
# visualize
summary(hyp)
## Select/sort on Pvalue, Count, etc.
```



Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Cmd+Option+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Cmd+Shift+K* to preview the HTML file). 

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.

