---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 
```{r}

#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install(c("readr","DESeq2","vsn", "ggfortify", "ggrepel", "ggplot2", "pheatmap", "devtools", "rmarkdown", "dynamicTreeCut", "fastcluster","WGCNA","magrittr"))

setwd("~/Desktop/Lab/research_2023/trapseq_2023")


library(readr)
featcount <- read_table("featcount.txt", 
                        col_names = TRUE, skip = 1)
read.count <- data.frame(featcount, row.names = featcount$Geneid ) #gene ids stored as row names
geneID<- featcount$Geneid

read.count <- read.count [ ,-c(1:6)] #removes the columns without gene counts not the same as bottom row code

orig_names <- names(read.count)
#print(orig_names)

colnames(read.count) <- (c("IT-107","IT-108", "IT-109", "IT-110", "H-107", "H-108", "H-109", "H-110","H-111", "UT-106", "UT-108", "UT-114", "IT-206", "IT-207", "IT-208", "IT-209", "IM-206", "IM-207", "IM-208", "IM-209", "IM-210", "UT-204", "UT-208", "UT-213", "UT-214", "UM-204", "UM-208", "UM-213", "UM-214", "UM-215")) 
#view(read.count)


ImvHvUM <- read.count [ ,-c(1:4, 10:16,22:25)]

sample_info <- data.frame(
  sample = c( "H-107", "H-108", "H-109", "H-110","H-111","IM-206", "IM-207", "IM-208", "IM-209", "IM-210","UM-204", "UM-208", "UM-213", "UM-214", "UM-215" ),
  groups=c( "H", "H", "H", "H","H", "IM", "IM", "IM", "IM", "IM","UM","UM","UM","UM","UM"),
  condition =c("Infected","Infected","Infected","Infected","Infected","Infected","Infected","Infected","Infected","Infected", "Uninfected","Uninfected","Uninfected","Uninfected","Uninfected"),
  replicate= c("H-107", "H-108", "H-109", "H-110","H-111", "IM-206", "IM-207", "IM-208", "IM-209", "IM-210","UM-204", "UM-208", "UM-213", "UM-214", "UM-215"),
  row.names = "sample") 


metadata <- as.data.frame.array(sample_info)

all(rownames(metadata) %in% colnames(ImvHvUM))


sample_info$groups<- as.factor(sample_info$groups)
all(rownames(sample_info) %in% colnames(ImvHvUM)) #if false something is wrong
sample_info 
```

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

```{r}
# 1 loading expression data
#BiocManager::install (c("preprocessCore", "impute", "AnnotationDbi", "GO.db"))

library("DESeq2")
#display the current working directory
getwd()

#load the WGCNA package and all of the dependencies
library(dynamicTreeCut)
library(fastcluster)
library(WGCNA)
library(cluster)
#the following setting is important, do not omit
options(stringsAsFactors = FALSE)
allowWGCNAThreads()


dds <- DESeqDataSetFromMatrix(countData = ImvHvUM,
                              colData = sample_info,
                              design = ~condition)
print(dds)

library(magrittr)
#prefiltering
dds <- (dds[ rowSums( counts(dds) ) > 10 , ])
```


```{r}
dds<-DESeq(dds)
datExpr0<- assay(dds)
gsg = goodSamplesGenes(datExpr0, verbose = 5);
gsg$allOK #If the allOK object returns true, which it does in this case, there are no outliers present. If it doesn’t return true, we need to filter out the outliers manually

#vsd = getVarianceStabilizedData(dds)
vsd <- vst(dds, blind = TRUE )


colnames(vsd)<- sample_info$replicate
datExpr <- assay(vsd) %>%
  t()  

rownames(datExpr) = colnames(vsd)
#'datExpr' data frame containing the expression data, columns corresponding to genes and rows to samples
```


```{r}
powers = c(c(1:10), seq(from = 12, to=20, by=2))
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
sft = pickSoftThreshold(datExpr,corFnc = "bicor", corOptions=list(maxPOutliers=0.1),
networkType = "signed hybrid", powerVector = powers, verbose = 5)
softpower = 6
nethybrid = blockwiseModules(datExpr, power = softpower,maxBlockSize = 30000,
TOMType = "signed", minModuleSize = 30,
reassignThreshold = 0, mergeCutHeight = 0.25,
numericLabels = TRUE, pamRespectsDendro = FALSE,
saveTOMs = FALSE, networkType = "signed hybrid",
verbose = 5,corType = "bicor", maxPOutliers = 0.1,
pearsonFallback = "individual")
```


```{r}
table(nethybrid$colors)
sizeGrWindow(12, 9)
mergedColors = labels2colors(nethybrid$colors)
#print(mergedColors)
plotDendroAndColors(nethybrid$dendrograms[[1]], mergedColors[nethybrid$blockGenes[[1]]],
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)
datME=moduleEigengenes(datExpr,nethybrid$colors)$eigengenes
signif(cor(datME, use="p"), 2)
dissimME=(1-t(cor(datME, method="p")))/2
hclustdatME=hclust(as.dist(dissimME), method="average" )
par(mfrow=c(1,1))
plot(hclustdatME, main="Clustering tree based of the module eigengenes")


sizeGrWindow(8,9)
#plotMEpairs(datME)
#signif(cor(datME, ModuleEigengeneNetwork1[,-1]),2)
sizeGrWindow(8,9)
par(mfrow=c(3,1), mar=c(1, 2, 4, 1))
which.module="turquoise";
plotMat(t(scale(datExpr[,mergedColors==which.module ]) ),nrgcols=30,rlabels=T,
clabels=T,rcols=which.module,
title=which.module )
which.module="blue";
plotMat(t(scale(datExpr[,mergedColors==which.module ]) ),nrgcols=30,rlabels=T,
clabels=T,rcols=which.module,
title=which.module )
which.module="yellow";
plotMat(t(scale(datExpr[,mergedColors==which.module ]) ),nrgcols=30,rlabels=T,
clabels=T,rcols=which.module,
title=which.module )
```


```{r}
#BiocManager::install (c("rrcov"))

datExpr0 = as.data.frame(t(ImvHvUM))
names(datExpr0)= geneID
rownames(datExpr0)=names(ImvHvUM)
datExpr0[] = lapply(datExpr0, as.numeric)
```


```{r}
#checking for the missing values and remotion of NA
gsg = goodSamplesGenes(datExpr0, verbose = 3);
gsg$allOK
#If the allOK object returns true, which it does in this case, there are no outliers present. If it doesn’t return true, we need to filter out the outliers manually
if (!gsg$allOK)
{
# Optionally, print the gene and sample names that were removed:
if (sum(!gsg$goodGenes)>0)
printFlush(paste("Removing genes:", paste(names(datExpr0)[!gsg$goodGenes], collapse = ", ")));
if (sum(!gsg$goodSamples)>0)
printFlush(paste("Removing samples:", paste(rownames(datExpr0)[!gsg$goodSamples], collapse = ", ")));
# Remove the offending genes and samples from the data:
datExpr0 = datExpr0[gsg$goodSamples, gsg$goodGenes]
#exprSize = checkSets(datExpr0)
}
```


```{r}
sampleTree = hclust(dist(datExpr), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
sizeGrWindow(12,9)
#pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,
cex.axis = 1.5, cex.main = 2)
# Plot a line to show the cut
abline(h = 355, col = "red");
# Determine cluster under the line
clust = cutreeStatic(sampleTree, cutHeight = 355, minSize = 10)
table(clust)

# clust 1 contains the samples we want to keep.
keepSamples = (clust==1)
datExpr = datExpr[keepSamples, ]
nGenes = ncol(datExpr)
nSamples = nrow(datExpr)
sampleTree = hclust(dist(datExpr), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
sizeGrWindow(12,9)
#pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,
cex.axis = 1.5, cex.main = 2)
```


```{r}
#how to detect outliers
library(rrcov)
pcaHub = PcaHubert(datExpr)
outliers = which(pcaHub@flag =="FALSE")
# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=20, by=2))
# Call the network topology analysis function
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)

# Plot the results:
sizeGrWindow(12, 9)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
```


```{r}
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")

net = blockwiseModules(datExpr, power = 6,
TOMType = "unsigned", maxBlockSize = 30000, minModuleSize = 30,
reassignThreshold = 0, mergeCutHeight = 0.89,
numericLabels = TRUE, pamRespectsDendro = FALSE,
saveTOMs = TRUE,
saveTOMFileBase = "spimp_TOM",
verbose = 3)
table(nethybrid$colors)
```


```{r}
# open a graphics window
sizeGrWindow(12, 9)
# Convert labels to colors for plotting
mergedColors = labels2colors(net$colors)
# Plot the dendrogram and the module colors underneath
plotDendroAndColors(net$dendrograms[[1]], mergedColors[net$blockGenes[[1]]],
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)
#module assignment
moduleLabels = nethybrid$colors
moduleColors = labels2colors(nethybrid$colors)
#module eigengene
MEs = nethybrid$MEs
geneTree = nethybrid$dendrograms[[1]]
```


```{r}
#traitData=read.csv("jh_metadata.csv")
pcapSamples = rownames(datExpr0);
traitRows = match(pcapSamples, metadata$replicate);
traitRows
datTraits = metadata[traitRows, -c(1:2)];
rownames(datTraits) = metadata[traitRows, 3];
datTraits[] = lapply(datTraits, as.numeric)
```


```{r}
# Re-cluster samples
sampleTree2 = hclust(dist(datExpr), method = "average")
# Convert traits to a color representation: white means low, red means high, grey means missing entry
traitColors = numbers2colors(pcapSamples, signed = FALSE);
# Plot the sample dendrogram and the colors underneath.
plotDendroAndColors(sampleTree2, traitColors,
#groupLabels = names(datTraits),
main = "Sample dendrogram and trait heatmap")
names(datExpr0)
# Define numbers of genes and samples
nGenes = ncol(datExpr);
nSamples = nrow(datExpr);
# Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr, moduleColors)$eigengenes
MEs = orderMEs(MEs0)
#moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);
sizeGrWindow(10,6)
# Will display correlations and their p-values
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)
par(mar = c(6, 8.5, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
#xLabels = names(datTraits),
yLabels = names(MEs),
ySymbols = names(MEs),
colorLabels = FALSE,
colors = greenWhiteRed(50),
textMatrix = textMatrix,
setStdMargins = FALSE,
cex.text = 0.5,
zlim = c(-1,1),
main = paste("Module-trait relationships"))
```


```{r}

# Define variable weight containing the weight column of datTrait
iron = as.data.frame(datTraits$DPI);
names(dpi) = "Dpi"
# names (colors) of the modules
modNames = substring(names(MEs), 3)
geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"));
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples));
names(geneModuleMembership) = paste("MM", modNames, sep="");
names(MMPvalue) = paste("p.MM", modNames, sep="");
geneTraitSignificance = as.data.frame(cor(datExpr, iron, use = "p"));
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples));
names(geneTraitSignificance) = paste("GS.", names(iron), sep="");
names(GSPvalue) = paste("p.GS.", names(iron), sep="");
#=====================================================================================
##
Code chunk 5
##
=====================================================================================
module = "lightcyan"
column = match(module, modNames);
moduleGenes = moduleColors==module;
sizeGrWindow(7, 7);
par(mfrow = c(1,1));
verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
abs(geneTraitSignificance[moduleGenes, 1]),
xlab = paste("Module Membership in", module, "module"),
ylab = "Gene significance for body weight",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module, )
#=====================================================================================
##
Code chunk 6
##
=====================================================================================
names(datExpr)
#=====================================================================================
##
Code chunk 7
##
=====================================================================================
iron_name=names(datExpr)[moduleColors=="lightcyan"]
write(iron_name, file ="iron_names.txt", sep = "\t")
#=====================================================================================
##
Code chunk 8
##
=====================================================================================
annot = read.csv(file = "GeneAnnotation.csv");
dim(annot)
names(annot)
probes = names(datExpr)
probes2annot = match(probes, annot$substanceBXH)
# The following is the number or probes without annotation:
sum(is.na(probes2annot))
# Should return 0.
#=====================================================================================
##
Code chunk 9
##
=====================================================================================
# Create the starting data frame
geneInfo0 = data.frame(substanceBXH = probes,
geneSymbol = annot$gene_symbol[probes2annot],
LocusLinkID = annot$LocusLinkID[probes2annot],
moduleColor = moduleColors,
geneTraitSignificance,
GSPvalue)
# Order modules by their significance for weight
modOrder = order(-abs(cor(MEs, weight, use = "p")));
# Add module membership information in the chosen order
for (mod in 1:ncol(geneModuleMembership))
{
oldNames = names(geneInfo0)
geneInfo0 = data.frame(geneInfo0, geneModuleMembership[, modOrder[mod]],
MMPvalue[, modOrder[mod]]);
names(geneInfo0) = c(oldNames, paste("MM.", modNames[modOrder[mod]], sep=""),
paste("p.MM.", modNames[modOrder[mod]], sep=""))
}#
Order the genes in the geneInfo variable first by module color, then by geneTraitSignificance
geneOrder = order(geneInfo0$moduleColor, -abs(geneInfo0$GS.weight));
geneInfo = geneInfo0[geneOrder, ]
TOM = TOMsimilarityFromExpr(datExpr, power = 6);
modules = c("brown", "lightcyan");
probes = names(datExpr)
inModule = is.finite(match(moduleColors, modules));
modProbes = probes[inModule];
modTOM = TOM[inModule, inModule];
dimnames(modTOM) = list(modProbes, modProbes)
cyt = exportNetworkToCytoscape(modTOM,
edgeFile = paste("CytoscapeInput-edges-", paste(modules, collapse="-"), ".txt", sep=""),
nodeFile = paste("CytoscapeInput-nodes-", paste(modules, collapse="-"), ".txt", sep=""),
weighted = TRUE,
threshold = 0.05,
nodeNames = modProbes,
altNodeNames = modProbes,
nodeAttr = moduleColors[inModule]);```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Cmd+Option+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Cmd+Shift+K* to preview the HTML file). 

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.