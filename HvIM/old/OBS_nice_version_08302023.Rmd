---
title: "RNAseq nice version"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

```{r}

```


```{r}
library(magrittr)
library(readr)
setwd("~/Desktop/Lab/Coding")
featcount <- read_table("featcount.txt", 
                        col_names = TRUE, skip = 1)

read.count <- featcount [ ,-c(1:6)] #removes the columns without gene counts not the same as bottom row code

read.count <- data.frame(featcount,row.names = featcount$Geneid ) #gene ids stored as row names

read.count <- read.count [ ,-c(1:6)] #removes the columns without gene counts not the same as bottom row code

orig_names <- names (read.count) 


colnames(read.count) <- (c("IT2", "IT3", "IT4", "H1", "H3", "H4", "H5", "UT1", "UT2", "UT3", "IT5", "IT6", "IT7", "IT8", "IM1", "IM2", "IM3", "IM4", "IM5", "UT4", "UT5", "UT6", "UT7", "UM1", "UM2", "UM3", "UM4", "UM5")) 
library(tidyverse)
view(read.count)


 sample_info <- data.frame(condition = gsub( "_[0 -9]+ " , " " , names(read.count),
),
    row.names = names(read.count))
 #Corresponding names and conditions, make sure everything matches up at this point
#DIC	- > IT infected, 
#DIT - >	H infected, 
#DMC - >	UT mock, 
#PIC	- > IT infected
#PIT	- > IM infected
#PMC	- > UT mock
#PMT	- > UM mock
```


```{r}
#filter lowly expressed genes, counts per million (cpm)
#converting to cpms, we are normalizing for the different sequencing depths for each sample

#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install("edgeR")
library(edgeR)
myCPM <-cpm(read.count)
head(myCPM)

#which values are greater than .5
thresh<- myCPM >0.5

#logical matrix of t/f
head(thresh)

#summary of trues in each row
table(rowSums(thresh))

#keep genes with at least 2 trues in each row
keep<-rowSums(thresh) >=2

#subset the rows of the read counts to keep the highly expressed genes
counts.keep <-read.count[keep,]
summary(keep)
dim(counts.keep)


plot(myCPM[,1],read.count[,1], ylim=c(0,50), xlim=c(0,3))
abline(v=0.5)

#shows that 0.5 does correspond to a count of 10-15 ish

```

```{r}
#Quality control 
dgeObj <- DGEList(counts.keep)
names(dgeObj)
dgeObj$samples

#lib sizes and distribution plots
barplot(dgeObj$samples$lib.size, names=colnames(dgeObj), las=2)
title("barplot of library sizes")
```


```{r}
#examining the distribution of raw counts 
#use box plot to check the distribution of read counts on the log2 scale

#get log2 counts per million
logcounts<-cpm(dgeObj,log=TRUE)

#check distribution of samples using boxplots, blue line corresponds to median log CPM
boxplot(logcounts, xlab="", ylab="Log2 counts per million", las=2)
abline(h=median(logcounts),col="blue")
title("Boxplot of logCPMs (unnormalised)")

#you can see that density distributions are not identical but not very different. samples far from blue line need further investigation
```

```{r}

DESeq.ds <- DESeqDataSetFromMatrix(countData = dgeObj,
                                   colData = sample_info,
                                   design = ~condition)
DESeq.ds
#barplot of lib sizes
#head(counts(DESeq.ds))
#counts(DESeq.ds) %>% str
#colSums(counts(DESeq.ds))
#colSums(counts(DESeq.ds)) %>% barplot(col="blueviolet")

# remove genes without any counts
#dim(DESeq.ds)
#keep_genes <- rowSums(counts(DESeq.ds)) >0
#DESeq.ds <- DESeq.ds[keep_genes,]
#dim(DESeq.ds)

counts(DESeq.ds) %>% str
assay(DESeq.ds) %>% str

# investigate different library sizes = sequencing depth
#colSums(counts(DESeq.ds))%>% barplot # should be the same as colSums (read.count), how many reads were counted for each sample/library size
#library size is the total number of reads sequenced or total mapped reads

#calculate size factor and add to the data set (size factor: median ratio for each sample)
DESeq.ds <-estimateSizeFactors(DESeq.ds)
plot(sizeFactors(DESeq.ds), colSums(counts(DESeq.ds)), 
     ylab="library sizes", xlab = "size factors", cex = .6, col = "mediumvioletred")



#set up the plotting layout
par(mfrow=c(1,1))
counts.sf_normalized <- data.frame(counts(DESeq.ds, normalized = TRUE))
countsnorm <- data.frame(counts.sf_normalized)
summary(countsnorm)
####Check results 
#colData (DESeq.ds) %>% head
#assay (DESeq.ds) %>% head
#rowRanges (DESeq.ds) %>% head

```


```{r}
#setting up plots
par(mfrow=c(1,1))

#extracting normalized counts
counts.sf_normalized<-counts(DESeq.ds, normalized=TRUE)

#adding boxplots
boxplot(counts.sf_normalized, main = "size factor normalized", cex=.6)
boxplot(counts(DESeq.ds), main="read counts only", cex=.6)

par(mfrow=c(1,1))
boxplot(log2(counts(DESeq.ds)+1), notch=TRUE,
        main="non-norm read counts",
        ylab="log2(read counts", cex=.6)
boxplot(log2(counts(DESeq.ds, normalize=TRUE)+1), notch=TRUE,
        main="Size factor norm read counts",
        ylab="log2(read counts", cex=.6)

```


```{r}
# non normalized read counts plus pseudocount
log.counts <- log2(counts(DESeq.ds, normalized = FALSE)+1)
assay(DESeq.ds, "log.counts") <- log2(counts(DESeq.ds, normalized = FALSE)+1)

#normalized read counts
log.norm.counts <- log2(counts(DESeq.ds, normalized = TRUE) + 1)

par(mfrow=c(1,1))
plot(log.norm.counts[,1:2], cex =.1 , main = "Normalized log2(read counts)", col = "turquoise")

#every dot= one gene, the wider lower part means that read counts correlate less well between replicated when they are low

#standard dev of the expression may depend on the mean (the lower the mean read counts per gene, the higher the standard deviation)
log.norm.counts<- log2(counts(DESeq.ds, normalized = TRUE)+1)

par(mfrow=c(1,1))
msd_plot <- vsn::meanSdPlot(log.norm.counts,
                            ranks = FALSE, 
                            plot = FALSE)
msd_plot$gg +
  ggtitle("seq depth normalized log2(read counts")+
  ylab("standard dev")

#red depict the running median estimator. 
#plot shows that there is some variance-mean dependence for genes with low read counts. means data shows signs of heteroskedasricity
```


```{r}
#reducing dependance on mean
DESeq.rlog<- rlog(DESeq.ds, blind=TRUE)

par(mfrow=c(1,1))
plot(log.norm.counts[,1:2], cex=.1,
     main = "size factor and log2 transformed",
     col="skyblue")

plot(assay(DESeq.rlog)[,1],
     assay(DESeq.rlog)[,2],
           cex=.1, main = "rlog transformed",
           xlab = colnames(assay(DESeq.rlog[,1])),
           ylab =colnames(assay(DESeq.rlog[,2])),
     col="thistle")

rlog.norm.counts<-assay(DESeq.rlog)
```


```{r}
#rlog-transformed read counts and mean sd 
msd_plot <-vsn::meanSdPlot(rlog.norm.counts, ranks=FALSE, plot = FALSE)
msd_plot$gg + ggtitle("rlog transformation") + coord_cartesian(ylim = c(0,3))

#adjusted at this point, differences in sequencing depth, differences in RNA composition, heteroskedasticity, large dynamic range so we can use it for exploratory analysis- de analyses

save.image(file = "RNAseqkasia.RDATA")
```



```{r}
# cor () calculates the correlation between columns of a matrix
library(corrplot)
corr_matrix <-cor(rlog.norm.counts)
corrplot(corr_matrix)

#PCA
data.pca <- princomp(corr_matrix)
summary(data.pca)


pc <- prcomp(t(rlog.norm.counts))
plot(pc$x[,1], pc$x[,2],
     col = colData(DESeq.ds) [,1], 
     main = "PCA of seq.depth normalized\n and rlog-transformed read counts")

 # PCA
P <-plotPCA(DESeq.rlog)

# plot cosmetics
P <- P + theme_bw() + ggtitle("Rlog transformed counts")
print(P)
```


```{r relationships between conditions}
distance.m_rlog <- as.dist(1-(cor(rlog.norm.counts, method = "pearson")) )
all_gene_tree <- hclust(distance.m_rlog, method = "complete")

# dendrogram plot () can directly interpret the output of hclust ()
#plot(all_gene_tree,
#     labels = colnames(rlog.norm.counts), cex=0.9,
#     main = "rlog transformed read counts\ndistance: Pearson correlation")

library(dendextend)
dend_allg<-as.dendrogram(all_gene_tree)

nleaves(dend_allg) # # of genes we clustered
nnodes(dend_allg) # # of nodes (leaves+joins) in tree

allg_clusters <- cutree(dend_allg, k=8, order_clusters_as_data = FALSE)
table(allg_clusters)
allg_clusters[1:6]

plot(color_branches(dend_allg, k=8, leaflab="none"))

allgenecluster.df <-data.frame(Condition=names(allg_clusters), cluster = allg_clusters)
allgenecluster3<-filter(allgenecluster.df, cluster==3)
cat(as.character(allgenecluster3[1]), quote=FALSE, sep = "\n")
```


```{r}
DESeq.ds <- estimateSizeFactors(DESeq.ds) # sequencing depth normalization between the samples
DESeq.ds <- estimateDispersions(DESeq.ds, maxit = 100, quiet = FALSE, modelMatrix = NULL) # gene - wise dispersion estimates across all samples
DESeq.ds <- nbinomWaldTest(DESeq.ds) # this fits a negative binomial GLM and applies Wald statistics to each gene
DGE.results<- results (DESeq.ds, independentFiltering = TRUE , alpha = 0.05)
summary (DGE.results)
```


```{r}
Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Cmd+Option+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Cmd+Shift+K* to preview the HTML file). 

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.