---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

# ICM 2025OCT6 TRAP Script
# UM v IM v H

```{r CODE CHUNK 1 CLEAR}
# Clean environment
rm (list = ls (all.names = TRUE)) # will clear all objects including hidden objects
gc () # free up memory and report the memory usage
options (max.print = .Machine$integer.max, scipen = 0, stringsAsFactors = F, dplyr.summarise.inform = F) # avoid truncated output in R console and keep scientific notation
```


```{r}
# Uncomment the following line to install BiocManager if not already installed
# if (!require("BiocManager", quietly = TRUE)) install.packages("BiocManager")

# ---- Install all required packages ----
# BiocManager::install(c(
#   "corrplot", "dendextend", "readr", "DESeq2", "ggrepel", "ggplot2",
#   "pheatmap", "devtools", "ggforce", "gplots", "RColorBrewer", "ggdendro",
#   "enrichplot", "magrittr", "dplyr", "tibble", "tidyverse", "ComplexHeatmap",
#   "escape", "xlsx", "clusterProfiler", "org.At.tair.db"
# ))

# ---- Install a single package ----
# BiocManager::install("...")

```


```{r}
# Set the working directory to your project folder
setwd("~/Desktop/Lab/TRAPseq/HvIM")
# Load necessary packages
suppressPackageStartupMessages({
  library(DESeq2)
  library(readr)
  library(tidyverse)
  library(vidger)
  library(enrichplot)
  #library(dplyr)
  #library(tibble)
  #library(magrittr)
  library(gplots)
  library(RColorBrewer)
  #library(corrplot)
#  library(ggdendro)
  library(dendextend)
  library(ggplot2)
  library(ggrepel)
  library(pheatmap)
  library(xlsx)
#  library(escape)
  library(clusterProfiler)
  library(org.At.tair.db)
  library(reshape2)
library(apeglm)
})
```


```{r}
# ---- Read in raw count data from text file ----
library(readr)

# Import data, skipping the first header line
featcount <- read_table(
  "Data_Repository/featcount.txt",
  col_names = TRUE,
  skip = 1
)

# Create a data frame and set gene IDs as row names
read.count <- data.frame(featcount, row.names = featcount$Geneid)

# Remove metadata columns (keep only count columns)
read.count <- read.count[, -c(1:6)]

# ---- Rename columns for consistency ----
orig_names <- names(read.count)  # Backup original names

colnames(read.count) <- c(
  "IT-107", "IT-108", "IT-109", "IT-110",
  "H-107", "H-108", "H-109", "H-110", "H-111",
  "UT-106", "UT-108", "UT-114",
  "IT-206", "IT-207", "IT-208", "IT-209",
  "IM-206", "IM-207", "IM-208", "IM-209", "IM-210",
  "UT-204", "UT-208", "UT-213", "UT-214",
  "UM-204", "UM-208", "UM-213", "UM-214", "UM-215"
)

#Check dimensions and column names
cat("Data dimensions:", dim(read.count), "\n")
```


```{r}
# ---- Subset read.count for IM, H, and UM comparisons ----
ImvHvUM <- read.count[, -c(1:4, 10:16, 22:25)]  # Remove irrelevant columns

# ---- Create sample metadata table ----
sample_info_UM <- data.frame(
  Sample = c(
    "H-107", "H-108", "H-109", "H-110", "H-111",
    "IM-206", "IM-207", "IM-208", "IM-209", "IM-210",
    "UM-204", "UM-208", "UM-213", "UM-214", "UM-215"
  ),
  Groups = c(
    rep("H", 5),
    rep("IM", 5),
    rep("UM", 5)
  ),
  Condition = c(
    rep("Infected", 10),
    rep("Uninfected", 5)
  ),
  Replicate = c(
    "H-107", "H-108", "H-109", "H-110", "H-111",
    "IM-206", "IM-207", "IM-208", "IM-209", "IM-210",
    "UM-204", "UM-208", "UM-213", "UM-214", "UM-215"
  ),
  row.names = "Sample"
)

# ---- Convert Groups to factor ----
sample_info_UM$Groups <- as.factor(sample_info_UM$Groups)

# ---- Check sample-to-column matching ----
match_check <- all(rownames(sample_info_UM) %in% colnames(ImvHvUM))

if (match_check) {
  cat("✅ Sample metadata matches count matrix columns. \n")
} else {
  cat("⚠️ Warning: Sample names do not match count matrix columns!\n")
  cat("Missing samples:\n")
  print(setdiff(rownames(sample_info_UM), colnames(ImvHvUM)))
}

```


```{r}
# ---- Create DESeq2 dataset ----
library(DESeq2)

# Construct DESeqDataSet from count matrix and sample metadata
data_set <- DESeqDataSetFromMatrix(
  countData = ImvHvUM,
  colData = sample_info_UM,
  design = ~ Groups
)

# ---- Prefilter low-count genes ----
data_set <- data_set[rowSums(counts(data_set)) > 10, ] # Keep genes with at least 10 total reads across all samples

# ---- Relevel control group ----
data_set$Groups <- relevel(data_set$Groups, ref = "UM") # Set 'UM' as the reference level for differential expression

# ---- Sanity checks ----
cat("Number of genes after filtering:", nrow(data_set), "\n")
cat("Group levels:", levels(data_set$Groups), "\n")

```


```{r}
# ---- Perform variance stabilizing transformation (VST) ----
library(DESeq2)
library(tibble)
library(openxlsx)

vsd <- vst(data_set) # Apply VST for visualization and clustering

colnames(assay(vsd)) <- sample_info_UM$Replicate # Rename columns to match sample replicate IDs

norm.counts <- assay(vsd) # Extract normalized (VST-transformed) counts matrix

# ---- Save normalized counts ----
# Save as CSV
# write.csv(
#   as.data.frame(norm.counts),
#   file = "./DerivedData/1_Diag_DEG/1_HvIMvUM_normalized.csv",
#   quote = FALSE,
#   row.names = TRUE
# )

# Save as Excel
# write.xlsx(
#   as.data.frame(norm.counts),
#   file = "./DerivedData/1_Diag_DEG/1_HvIMvUM_normalized.xlsx",
#   sheetName = "normalized",
#   colNames = TRUE,
#   rowNames = TRUE,
#   append = FALSE
# )

# ---- Sanity check ----
cat("VST transformation complete.\n")
cat("Dimensions of normalized matrix:", dim(norm.counts), "\n")

```

```{r}
# ---- Sample correlation heatmap ----
library(reshape2)
library(ggplot2)

sim_mat <- norm.counts[rowSums(norm.counts) >= 1, ] # Filter genes with at least 1 read across all samples

cor_samps <- round(cor(sim_mat, method = "spearman"), digits = 2) # Compute Spearman correlation between samples

melted_cor_samps <- melt(cor_samps, varnames = c("Sample1", "Sample2"), value.name = "Correlation") # Melt correlation matrix for ggplot

# Plot correlation heatmap
ggheatmap <- ggplot(melted_cor_samps, aes(x = Sample1, y = Sample2, fill = Correlation)) +
  geom_tile() +
  geom_text(aes(label = Correlation), color = "white", size = 4) +
  scale_fill_gradient2(low = "darkblue", mid = "white", high = "hotpink", midpoint = 0.5) +
  theme_minimal(base_size = 13) +
  theme(
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    panel.grid = element_blank()
  ) +
  ggtitle("Sample Correlation Heatmap (Spearman, VST-normalized)")

print(ggheatmap)
# ggsave("./SumData/1_Diag_DEG/1_SampleCorrelationHeatmap.pdf", ggheatmap, width = 10, height = 8)


# ---- Sample distance and hierarchical clustering ----
library(dendextend)
library(RColorBrewer)
library(pheatmap)

# Compute Spearman correlation from VST normalized counts
sample_dist <- norm.counts[complete.cases(norm.counts), ]
correlation_matrix <- cor(sample_dist, method = "spearman")
dist_matrix <- as.dist(1 - correlation_matrix)

# Perform hierarchical clustering
clustering_result <- hclust(dist_matrix, method = "complete")

# Convert to dendrogram and color branches
dendrogram_object <- as.dendrogram(clustering_result) %>%
  color_branches(k = 3)

# Plot dendrogram
plot(
  dendrogram_object,
  type = "rectangle",
  ylab = "Height",
  main = "VST Read Counts - Hierarchical Clustering (Spearman Distance)"
)
# dev.copy2pdf(file = "./SumData/1_Diag_DEG/1_Diag_DEG_Dendrogram.pdf")


# ---- Distance matrix heatmap ----
DistMatrix <- as.matrix(dist_matrix)
rownames(DistMatrix) <- colnames(norm.counts)
colnames(DistMatrix) <- colnames(norm.counts)

color_scheme <- colorRampPalette(rev(brewer.pal(9, "Blues")))(255)

pheatmap(
  DistMatrix,
  clustering_distance_rows = dist_matrix,
  clustering_distance_cols = dist_matrix,
  color = color_scheme,
  main = "Sample Distance Matrix Heatmap (Spearman)",
  fontsize = 10
)
# dev.copy2pdf(file = "./SumData/1_Diag_DEG/1_DistMatrix.pdf")

```

```{r}
# ---- Differential Expression Analysis ----
library(DESeq2)

# Perform DESeq2 analysis
results_object <- DESeq(data_set)

# Extract results (using default comparison: other groups vs reference level "UM")
res <- results(results_object)

# ---- Sanity checks ----
cat("DESeq2 analysis complete.\n")
cat("Number of genes tested:", nrow(res), "\n")
cat("Number of genes pass (padj < 0.05):", sum(res$padj < 0.05, na.rm = TRUE), "\n")

# ---- Order results by adjusted p-value ----
res <- res[order(res$padj), ]

# ---- Inspect top results ----
head(res)

# ---- Save DESeq2 results ----
# write.csv(
#   as.data.frame(res),
#   file = "./DerivedData/1_Diag_DEG/2_DESeq2_results_HvIMvUM.csv",
#   quote = FALSE,
#   row.names = TRUE
# )

```

```{r}
# ---- PCA: Visualize sample clustering based on VST-normalized counts ----
library(DESeq2)
library(ggplot2)
library(ggrepel)

# Compute PCA from VST-transformed data
pc_data <- plotPCA(vsd, intgroup = c("Replicate", "Groups"), returnData = TRUE)
percentVar <- round(100 * attr(pc_data, "percentVar"))

# Define custom colors for each group (make sure these match your factor levels)
group_colors <- c("H" = "#E41A1C", "IM" = "#4DAF4A", "UM" = "#377EB8")  # red, green, blue

# Base PCA plot
pca_plot <- ggplot(pc_data, aes(x = PC1, y = PC2, color = Groups, shape = Groups, label = Replicate)) +
  geom_point(size = 4, alpha = 0.9) +
  geom_text_repel(size = 3.5, max.overlaps = 25, box.padding = 0.5, segment.linetype = 2) +
  scale_color_manual(values = group_colors) +
  labs(
    title = "PCA of VST-Normalized Gene Counts",
    x = paste0("PC1: ", percentVar[1], "% variance"),
    y = paste0("PC2: ", percentVar[2], "% variance")
  ) +
  theme_classic(base_size = 14) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    legend.title = element_blank(),
    legend.position = "right",
    axis.text = element_text(color = "black")
  ) 
# Print and save
print(pca_plot)
# ggsave("./SumData/1_Diag_DEG/1_PCA_Final_IMVUMVH_v2.pdf", plot = pca_plot, width = 6, height = 6)

```

```{r}
# Standard DESeq2 results
resHUM <- results(results_object, contrast = c("Groups", "H", "UM"), alpha = 0.05)
resIMUM <- results(results_object, contrast = c("Groups", "IM", "UM"), alpha = 0.05)

# LFC shrinkage for more accurate fold changes
lfcHUM <- lfcShrink(results_object, coef = "Groups_H_vs_UM", type = "apeglm")
lfcIMUM <- lfcShrink(results_object, coef = "Groups_IM_vs_UM", type = "apeglm")

# Sort by adjusted p-value
lfcHUM <- lfcHUM[order(lfcHUM$padj, na.last = NA), ]
lfcIMUM <- lfcIMUM[order(lfcIMUM$padj, na.last = NA), ]
```


```{r}
# ---- Convert DESeq2 and LFC-shrink results to tidy tibbles ----
library(tibble)
library(dplyr)

# LFC-shrunken results
lfcHUM_tbl <- as_tibble(lfcHUM, rownames = "Gene_ID") %>% 
  mutate(group = "HvUM")  # Label group

lfcIMUM_tbl <- as_tibble(lfcIMUM, rownames = "Gene_ID") %>% 
  mutate(group = "IMvUM") # Label group

# Raw DESeq2 results
resHUM_tbl <- as_tibble(resHUM, rownames = "Gene_ID") %>% 
  mutate(group = "resHUM") # Label group

resIMUM_tbl <- as_tibble(resIMUM, rownames = "Gene_ID") %>% 
  mutate(group = "resIMUM") # Label group

# ---- Inspect the first few rows ----
head(lfcHUM_tbl)
head(lfcIMUM_tbl)
head(resHUM_tbl)
head(resIMUM_tbl)

```

```{r}
library(ggplot2)
library(dplyr)

# ---- Combine LFC tables and create clean columns ----
all_lfc <- lfcHUM_tbl %>% 
  inner_join(lfcIMUM_tbl, by = "Gene_ID") %>% 
  dplyr::select(-pvalue.x, -pvalue.y) %>% 
  mutate(
    L2FC_HUM = log2FoldChange.x,
    L2FC_IMUM = log2FoldChange.y,
    padj_HUM = padj.x,
    padj_IMUM = padj.y
  )

# ---- Basic volcano plot: H vs UM ----
lfcHUM_tbl %>%
  ggplot(aes(x = log2FoldChange, y = -log10(padj))) +
  geom_point(alpha = 0.6, color = "steelblue") +
  theme_classic(base_size = 14) +
  labs(
    title = "Volcano Plot: H vs UM",
    x = "Log2 Fold Change",
    y = "-log10(padj)"
  )

# ---- Basic volcano plot: IM vs UM ----
lfcIMUM_tbl %>%
  ggplot(aes(x = log2FoldChange, y = -log10(padj))) +
  geom_point(alpha = 0.6, color = "forestgreen") +
  theme_classic(base_size = 14) +
  labs(
    title = "Volcano Plot: IM vs UM",
    x = "Log2 Fold Change",
    y = "-log10(padj)"
  )

```


```{r}
library(dplyr)
library(tidyr)

# ---- Reshape log2 fold-change (LFC) columns to long format ----
lfc_long <- all_lfc %>% 
  dplyr::select(Gene_ID, L2FC_HUM, L2FC_IMUM) %>%
  pivot_longer(
    cols = -Gene_ID,
    names_to = "Groups",
    values_to = "Expression"
  ) %>%
  mutate(Groups = recode(Groups, "L2FC_HUM" = "HvUM", "L2FC_IMUM" = "IMvUM"))

# ---- Reshape adjusted p-value columns to long format ----
pval_long <- all_lfc %>% 
  dplyr::select(Gene_ID, padj_HUM, padj_IMUM) %>%
  pivot_longer(
    cols = -Gene_ID,
    names_to = "Groups",
    values_to = "Pvalue"
  ) %>%
  mutate(Groups = recode(Groups, "padj_HUM" = "HvUM", "padj_IMUM" = "IMvUM"))

# ---- Merge LFC and p-value tables ----
exp_tbl <- inner_join(lfc_long, pval_long, by = c("Gene_ID", "Groups"))

# ---- Inspect the result ----
head(exp_tbl)

```
```{r}
exp_tbl <- exp_tbl %>% 
  mutate(
    ExpSig = case_when(
      Expression >= 1 & Pvalue <= 0.05  ~ "Up-regulated",    # log2FC >= 1
      Expression <= -1 & Pvalue <= 0.05 ~ "Down-regulated",  # log2FC <= -1
      TRUE ~ "Unchanged"
    )
  )

# Keep only significant genes
exp_tbl1 <- exp_tbl %>% filter(ExpSig != "Unchanged")

```

```{r}
library(dplyr)
library(readxl)
library(tibble)

# Read transporter list
transporter_list <- read_xlsx("./RawData/6_transporter_df.xlsx")

# Filter significant genes for transporters
submod1 <- exp_tbl1 %>%
  filter(Gene_ID %in% transporter_list$TAIR) %>%
  na.omit()

# Split by Groups
submod1_split <- split(submod1, submod1$Groups)
names(submod1_split)  # check what groups exist

# Extract HvUM safely
HvUM_df <- submod1_split[["HvUM"]]   # make sure "HvUM" matches your group name
HvUM_df <- as.data.frame(HvUM_df)    # <- convert tibble to plain data frame
rownames(HvUM_df) <- HvUM_df$Gene_ID
#HvUM_df$Gene_ID <- NULL               # remove Gene_ID column if desired
HvUM_split <- split(HvUM_df, HvUM_df$ExpSig)
HUM_TL_UP<- as.data.frame(HvUM_split$`Up-regulated`)
HUM_TL_Dwn<- as.data.frame(HvUM_split$`Down-regulated`)





# Extract IMvUM safely
IMvUM_df <- submod1_split[["IMvUM"]]
IMvUM_df <- as.data.frame(IMvUM_df)
rownames(IMvUM_df) <- IMvUM_df$Gene_ID
#IMvUM_df$Gene_ID <- NULL
IMvUM_split <- split(IMvUM_df, IMvUM_df$ExpSig)
IMvUM_TL_UP<- as.data.frame(IMvUM_split$`Up-regulated`)
IMvUM_TL_Dwn<- as.data.frame(IMvUM_split$`Down-regulated`)

# Inspect
head(HvUM_df)
head(IMvUM_df)
```


```{r}
# ---- GO Enrichment (Biological Process) ----
library(clusterProfiler)
library(org.At.tair.db)
library(enrichplot)
library(ggplot2)

# ---- GO: H vs UM ----
ego_HUM_dwn_TL <- enrichGO(
  gene          = HUM_TL_Dwn$Gene_ID,
  OrgDb         = org.At.tair.db,
  keyType       = "TAIR",
  ont           = "ALL",
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.05,
  qvalueCutoff  = 0.05,
  readable      = TRUE
)

ego_HUM_up_TL <- enrichGO(
  gene          = HUM_TL_UP$Gene_ID,  
  OrgDb         = org.At.tair.db,
  keyType       = "TAIR",
  ont           = "ALL",
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.05,
  qvalueCutoff  = 0.05,
  readable      = TRUE
)

# ---- GO: IM vs UM ----
ego_IM_dwn_TL <- enrichGO(
  gene          = IMvUM_TL_Dwn$Gene_ID,
  OrgDb         = org.At.tair.db,
  keyType       = "TAIR",
  ont           = "ALL",
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.05,
  qvalueCutoff  = 0.05,
  readable      = TRUE
)

ego_IM_up_TL <- enrichGO(
  gene          = IMvUM_TL_UP$Gene_ID,
  OrgDb         = org.At.tair.db,
  keyType       = "TAIR",
  ont           = "ALL",
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.05,
  qvalueCutoff  = 0.05,
  readable      = TRUE
)

library(clusterProfiler)
library(enrichplot)

# Combine all four enrichment results into one object
combined_GO_all <- merge_result(list(
  HUM_Down = ego_HUM_dwn_TL,
  IMUM_Down  = ego_IM_dwn_TL,
   HUM_Up   = ego_HUM_up_TL,
  IMUM_Up    = ego_IM_up_TL
))

dotplot(combined_GO_all,
        showCategory = 15,
        title = "Combined GO Enrichment: H vs UM and IM vs UM (ALL)") +
  theme(axis.text.y = element_text(size = 10))
```

```{r}
# ---- KEGG: H vs UM ----
ekegg_HUM_dwn_TL <- enrichKEGG(
  gene          = HUM_TL_Dwn$Gene_ID,
  organism      = "ath",
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.05,
  qvalueCutoff  = 0.05
)

ekegg_HUM_up_TL <- enrichKEGG(
  gene          = HUM_TL_UP$Gene_ID,
  organism      = "ath",
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.05,
  qvalueCutoff  = 0.05
)

# ---- KEGG: IM vs UM ----
ekegg_IM_dwn_TL <- enrichKEGG(
  gene          = IMvUM_TL_Dwn$Gene_ID,
  organism      = "ath",
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.05,
  qvalueCutoff  = 0.05
)

ekegg_IM_up_TL <- enrichKEGG(
  gene          = IMvUM_TL_UP$Gene_ID,
  organism      = "ath",
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.05,
  qvalueCutoff  = 0.05
)

# ---- Load required packages ----
library(clusterProfiler)
library(enrichplot)

# ---- Combine all KEGG enrichment results ----
combined_KEGG_all <- merge_result(list(
  HUM_Down  = ekegg_HUM_dwn_TL,
  IMUM_Down = ekegg_IM_dwn_TL,
  HUM_Up    = ekegg_HUM_up_TL,
  IMUM_Up   = ekegg_IM_up_TL
))

# ---- Visualize combined KEGG enrichment ----
dotplot(combined_KEGG_all,
        showCategory = 15,
        title = "Combined KEGG Enrichment: H vs UM and IM vs UM") +
  theme(axis.text.y = element_text(size = 10))

```


```{r}
library(dplyr)
library(pheatmap)
library(RColorBrewer)
library(tibble)

set.seed(123)

# ---- Top 2000 DEGs ----
significant_genes <- res %>%
  as.data.frame() %>%
  filter(padj < 0.05, abs(log2FoldChange) >= 1)

DGE_sorted <- significant_genes[order(significant_genes$padj), ]
top_DGE_genes <- rownames(DGE_sorted)

# ---- Extract normalized counts for heatmap ----
hm_mat <- norm.counts[top_DGE_genes, ]

# ---- Column annotation ----
annotation_col <- data.frame(
  Group = sample_info_UM$Groups
)
rownames(annotation_col) <- sample_info_UM$Replicate

ann_colors <- list(
  Group = c(UM = "#C3A6FF", IM = "#A3F7BF", H = "hotpink")
)

# ---- Check alignment ----
message("Checking column names match between hm_mat and sample_info_UM...")
print(all(colnames(hm_mat) %in% sample_info_UM$Replicate))

# ---- Reorder samples by group ----
ordered_samples <- sample_info_UM %>%
  arrange(factor(Groups, levels = c("UM", "IM", "H"))) %>%
  pull(Replicate)

# Ensure overlap only includes matched names
ordered_samples <- intersect(ordered_samples, colnames(hm_mat))

# Apply the new order to both matrix and annotation
hm_mat <- hm_mat[, ordered_samples, drop = FALSE]
annotation_col <- annotation_col[ordered_samples, , drop = FALSE]

message("Sample order applied:")
print(ordered_samples)

# ---- Plot heatmap ----
pheatmap(
  hm_mat,
  show_rownames = FALSE,
  angle_col = 45,
  color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100),
  cluster_rows = TRUE,
  cluster_cols = FALSE,  # keep manual group order
  clustering_distance_rows = "correlation",
  clustering_method = "complete",
  scale = "row",
  annotation_col = annotation_col,
  annotation_colors = ann_colors,
  main = "Grouped DEGs (padj < 0.05, |LFC| ≥ 1)"
)

# ----save ----
# dev.copy2pdf(file = "./SumData/1_Diag_DEG/1_hmap_IMvHvUM_grouped.pdf")

```

```{r}
library(pheatmap)
library(RColorBrewer)
library(dplyr)
library(tidyr)

# ---- Filter significant genes ----
significant_genes <- res %>%
  as.data.frame() %>%
  filter(padj < 0.05, abs(log2FoldChange) >= 1)

# ---- Get normalized counts for these genes ----
hm_mat <- norm.counts[rownames(significant_genes), ]

# ---- Add sample info ----
sample_info_UM$Groups <- factor(sample_info_UM$Groups, levels = c("UM", "IM", "H"))

# ---- Calculate average expression per group ----
avg_expr <- hm_mat %>%
  as.data.frame() %>%
  t() %>%
  as.data.frame() %>%
  mutate(Group = sample_info_UM$Groups) %>%
  group_by(Group) %>%
  summarise(across(everything(), mean)) %>%
  column_to_rownames("Group") %>%
  t()

# ---- Convert counts to log2 fold change ----
# Compare to the UM baseline (control)
lfc_mat <- log2(avg_expr[, c("IM", "H")] + 1) - log2(avg_expr[, "UM"] + 1)

# ---- Color scale ----
lfc_colors <- colorRampPalette(rev(brewer.pal(7, "RdBu")))(100)

# ---- Plot heatmap ----
pheatmap(
  lfc_mat,
  color = lfc_colors,
  scale = "none",
  cluster_rows = TRUE,
  cluster_cols = FALSE,
  show_colnames = TRUE,
  show_rownames = FALSE,
  main = "Average Log₂ Fold Change per Group (vs UM)",
  border_color = NA
)

```
```{r}
library(pheatmap)
library(RColorBrewer)
library(dplyr)
library(tidyr)

# ---- Filter significant genes ----
significant_genes <- res %>%
  as.data.frame() %>%
  filter(padj < 0.05, abs(log2FoldChange) >= 1)

# ---- Extract normalized counts for these genes ----
hm_mat <- norm.counts[rownames(significant_genes), ]

# ---- Add sample info ----
sample_info_UM$Groups <- factor(sample_info_UM$Groups, levels = c("UM", "IM", "H"))

# ---- Average normalized expression per group ----
avg_expr <- hm_mat %>%
  as.data.frame() %>%
  t() %>%
  as.data.frame() %>%
  mutate(Group = sample_info_UM$Groups) %>%
  group_by(Group) %>%
  summarise(across(everything(), mean)) %>%
  column_to_rownames("Group") %>%
  t()

# ---- Compute log2 fold change relative to UM ----
lfc_mat <- log2(avg_expr[, c("IM", "H")] + 1) - log2(avg_expr[, "UM"] + 1)

# ---- Select top 50 most variable genes ----
gene_variance <- apply(lfc_mat, 1, var)
top_genes <- names(sort(gene_variance, decreasing = TRUE))[1:50]
lfc_mat_top <- lfc_mat[top_genes, ]

# ---- Color palette ----
lfc_colors <- colorRampPalette(rev(brewer.pal(7, "RdBu")))(100)

# ---- Plot heatmap ----
pheatmap(
  lfc_mat_top,
  color = lfc_colors,
  scale = "none",
  cluster_rows = TRUE,
  cluster_cols = FALSE,
  show_colnames = TRUE,
  show_rownames = TRUE,
  fontsize_row = 6,
  main = "Top 50 Variable Genes: Log₂ Fold Change (vs UM)",
  border_color = NA
)



```


```{r}
# ============================================================
# Differential Expression Data Processing
# ============================================================

library(dplyr)
library(tibble)

# ---- Split the data frame into sub-data frames: H vs UM and IM vs UM ----
results_split <- split(exp_tbl, exp_tbl$Groups)

# Check available group names
print(names(results_split))
# [1] "HvUM" "IMvUM"

# ---- Create Data Frames for Each Comparison ----
HvUM_df  <- as.data.frame(results_split$HvUM)
IMvUM_df <- as.data.frame(results_split$IMvUM)


# ---- Filter for DEGs ----
padj_cutoff <- 0.05
lfc_cutoff  <- 1



HvUM_DEG_df <- HvUM_df %>%
  filter(Pvalue < padj_cutoff, abs(Expression) >= lfc_cutoff)

IMvUM_DEG_df <- IMvUM_df %>%
  filter(Pvalue < padj_cutoff, abs(Expression) >= lfc_cutoff)

# ---- Check DEG counts ----
cat("HvUM DEGs:", nrow(HvUM_DEG_df), "\n")
cat("IMvUM DEGs:", nrow(IMvUM_DEG_df), "\n")

# ---- (Optional) Write to file ----
# write.csv(HvUM_DEG_df, "./DerivedData/1_Diag_DEG/HvUM_DEGs.csv", row.names = TRUE)
# write.csv(IMvUM_DEG_df, "./DerivedData/1_Diag_DEG/IMvUM_DEGs.csv", row.names = TRUE)

```

```{r}

HvUM_DEG_split <- split(HvUM_df, HvUM_df$ExpSig)
IMvUM_DEG_split <- split(IMvUM_df, IMvUM_df$ExpSig)

HvUM_df_split_Dwn  <- as.data.frame(HvUM_DEG_split$`Down-regulated`)
HvUM_df_split_Up  <- as.data.frame(HvUM_DEG_split$`Up-regulated`)


IMvUM_df_split_Dwn <- as.data.frame(IMvUM_DEG_split$`Down-regulated`)
IMvUM_df_split_Up <- as.data.frame(IMvUM_DEG_split$`Up-regulated`)
```


```{r}
# ============================================================
# GO and KEGG Enrichment Analysis
# ============================================================

# ---- GO Enrichment (Biological Process) ----
library(clusterProfiler)
library(org.At.tair.db)
library(enrichplot)
library(ggplot2)

# ---- GO: H vs UM ----
ego_HUM_dwn <- enrichGO(
  gene          = HvUM_df_split_Dwn$Gene_ID,
  OrgDb         = org.At.tair.db,
  keyType       = "TAIR",
  ont           = "ALL",
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.05,
  qvalueCutoff  = 0.05,
  readable      = TRUE
)

ego_HUM_up <- enrichGO(
  gene          = HvUM_df_split_Up$Gene_ID,
  OrgDb         = org.At.tair.db,
  keyType       = "TAIR",
  ont           = "ALL",
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.05,
  qvalueCutoff  = 0.05,
  readable      = TRUE
)

# ---- GO: IM vs UM ----
ego_IM_dwn <- enrichGO(
  gene          = IMvUM_df_split_Dwn$Gene_ID,
  OrgDb         = org.At.tair.db,
  keyType       = "TAIR",
  ont           = "ALL",
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.05,
  qvalueCutoff  = 0.05,
  readable      = TRUE
)

ego_IM_up <- enrichGO(
  gene          = IMvUM_df_split_Up$Gene_ID,
  OrgDb         = org.At.tair.db,
  keyType       = "TAIR",
  ont           = "ALL",
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.05,
  qvalueCutoff  = 0.05,
  readable      = TRUE
)

library(clusterProfiler)
library(enrichplot)

# Combine all four enrichment results into one object
combined_GO_all <- merge_result(list(
  HUM_Down = ego_HUM_dwn,
  IMUM_Down  = ego_IM_dwn,
   HUM_Up   = ego_HUM_up,
  IMUM_Up    = ego_IM_up
))

dotplot(combined_GO_all,
        showCategory = 15,
        title = "Combined GO Enrichment: H vs UM and IM vs UM (ALL)") +
  theme(axis.text.y = element_text(size = 10))
```


```{r}
# ---- KEGG Pathway Enrichment ----
ekegg_HUM_dwn <- enrichKEGG(
  gene         = HvUM_df_split_Dwn$Gene_ID,
  organism     = "ath",   # Arabidopsis thaliana
  pvalueCutoff = 0.05
)
ekegg_HUM_up <- enrichKEGG(
  gene         = HvUM_df_split_Up$Gene_ID,
  organism     = "ath",   # Arabidopsis thaliana
  pvalueCutoff = 0.05
)

ekegg_IMUM_dwn <- enrichKEGG(
  gene         = IMvUM_df_split_Dwn$Gene_ID,
  organism     = "ath",
  pvalueCutoff = 0.05
)
ekegg_IMUM_up <- enrichKEGG(
  gene         = IMvUM_df_split_Up$Gene_ID,
  organism     = "ath",
  pvalueCutoff = 0.05
)

library(clusterProfiler)
library(enrichplot)

# Combine KEGG enrichments
combined_KEGG_all <- merge_result(list(
  HUM_Down = ekegg_HUM_dwn,
   IM_Down  = ekegg_IMUM_dwn,
  HUM_Up   = ekegg_HUM_up,
  IM_Up    = ekegg_IMUM_up
))
dotplot(combined_KEGG_all,
        showCategory = 7,
        title = "Combined KEGG Enrichment: H vs UM and IM vs UM") +
  theme(axis.text.y = element_text(size = 10))


# ---- Save Results ----
#write.xlsx(
  list(
    "GO_HvUM" = as.data.frame(ego_HUM),
    "GO_IMvUM" = as.data.frame(ego_IMUM),
    "KEGG_HvUM" = as.data.frame(ekegg_HUM),
    "KEGG_IMvUM" = as.data.frame(ekegg_IMUM)
  ),
  file = "./DerivedData/1_Diag_DEG/GO_KEGG_Results.xlsx",
  overwrite = TRUE
)

```



```{r}
library(dplyr)
library(pheatmap)
library(RColorBrewer)
library(readxl)
library(tibble)

# ---- Read transporter gene list ----
transporter_list <- read_xlsx("./RawData/6_transporter_df.xlsx")

# ---- Filter significant DEGs for transporter genes ----
transporter_DEGs <- exp_tbl1 %>%
  filter(Gene_ID %in% transporter_list$TAIR)

# ---- Extract normalized counts for transporter DEGs ----
transporter_hm_mat <- norm.counts[transporter_DEGs$Gene_ID, ]

# ---- Column annotation for sample groups ----
annotation_col <- data.frame(Group = sample_info_UM$Groups)
rownames(annotation_col) <- sample_info_UM$Replicate

ann_colors <- list(
  Group = c(UM = "#C3A6FF", IM = "#A3F7BF", H = "hotpink")
)

# ---- Check alignment ----
message("Checking column names match between transporter_hm_mat and sample_info_UM...")
print(all(colnames(transporter_hm_mat) %in% sample_info_UM$Replicate))

# ---- Reorder samples by group ----
ordered_samples <- sample_info_UM %>%
  arrange(factor(Groups, levels = c("UM", "IM", "H"))) %>%
  pull(Replicate)

# Ensure overlap only includes matched names
ordered_samples <- intersect(ordered_samples, colnames(transporter_hm_mat))

# Apply new order to matrix and annotation
transporter_hm_mat <- transporter_hm_mat[, ordered_samples, drop = FALSE]
annotation_col <- annotation_col[ordered_samples, , drop = FALSE]

message("Sample order applied:")
print(ordered_samples)


# ---- Plot heatmap ----
pheatmap(
  transporter_hm_mat,
  show_rownames = FALSE,          # show transporter gene IDs
  angle_col = 45,
  color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100),
  cluster_rows = TRUE,
  cluster_cols = FALSE,          # keep grouped order
  clustering_distance_rows = "correlation",
  clustering_method = "complete",
  scale = "row",
  annotation_col = annotation_col,
  annotation_colors = ann_colors,
  main = "Transporter Genes - DEGs (padj < 0.05, |LFC| ≥ 1)"
)

# ---- Optional: save ----
# dev.copy2pdf(file = "./SumData/1_Diag_DEG/Transporter_DEG_Heatmap.pdf")

```

```{r}
library(tidyverse)
library(pheatmap)
library(RColorBrewer)
library(readxl)

set.seed(123)

# ---- Read transporter gene list ----
transporter_list <- read_xlsx("./RawData/6_transporter_df.xlsx")

# ---- Filter for transporter DEGs ----
transporter_DEGs <- exp_tbl1 %>%
  filter(Gene_ID %in% transporter_list$TAIR)

# ---- Extract normalized counts ----
transporter_counts <- norm.counts[transporter_DEGs$Gene_ID, ]

# ---- Calculate mean per group ----
group_means <- data.frame(
  UM = rowMeans(transporter_counts[, sample_info_UM$Groups == "UM"]),
  IM = rowMeans(transporter_counts[, sample_info_UM$Groups == "IM"]),
  H  = rowMeans(transporter_counts[, sample_info_UM$Groups == "H"])
)

# ---- Compute log2 fold change vs UM ----
log2FC_mat <- data.frame(
  IM_vs_UM = log2(group_means$IM + 1) - log2(group_means$UM + 1),
  H_vs_UM  = log2(group_means$H + 1) - log2(group_means$UM + 1)
)
rownames(log2FC_mat) <- rownames(group_means)

# ---- Optional: keep only top transporters by absolute log2FC ----
top_transporters <- log2FC_mat %>%
  mutate(maxFC = apply(., 1, function(x) max(abs(x)))) %>%
  arrange(desc(maxFC)) %>%
  head(50)  # top 50 by fold change
log2FC_mat_top <- log2FC_mat[rownames(top_transporters), ]

# ---- Heatmap color scale ----
pheatmap(
  log2FC_mat_top,
  cluster_rows = TRUE,
  cluster_cols = FALSE,
  color = colorRampPalette(rev(brewer.pal(7, "RdBu")))(100),
  main = "Log2 Fold Change (vs UM) – Top Transporter Genes",
  display_numbers = FALSE,
  fontsize_row = 8,
  angle_col = 45,
  border_color = NA
)


```

```{r}
library(vidger)
# ---- Read and clean your data ----
Supplemental_Tables_2nd_submission <- read_excel(
  "~/Desktop/kiad326_supplementary_data/Supplemental Tables_2nd_submission.xlsx", 
  sheet = "Table S3"
)

TB_DMR6 <- as.data.frame(Supplemental_Tables_2nd_submission$`Table S3. Lists of differentially expressed candidate genes.`)
TB_DMR6 <- TB_DMR6[-c(1, 2), ]

# Extract valid Arabidopsis gene IDs
hl <- TB_DMR6 %>%
  unlist() %>%
  na.omit() %>%
  unique() %>%
  grep("^AT[1-5]G\\d{5}$", ., value = TRUE)

# ---- Generate the vsFourWay plot ----

library(dplyr)
library(ggplot2)

# ---- Create your plot ----
FW_plot <- vsFourWay(
  x = "H", y = "IM",
  control = "UM",
  data = results_object,
  d.factor = "Groups",
  type = "deseq",
  padj = 0.05,
  lfc = 1,
  title = TRUE,
  grid = TRUE,
  legend = TRUE,
  highlight = hl,
  xaxis.text.size = 10,
  yaxis.text.size = 10,
  xaxis.title.size = 10,
  yaxis.title.size = 10,
  main.title.size = 10,
  legend.text.size = 10
)

# ---- Extract the DESeq2 results data ----
# Convert to data frame
FW_data <- as.data.frame(SummarizedExperiment::assay(results_object))
FW_data$Gene <- rownames(FW_data)


FW_plot +
  geom_abline(
    slope = 1, intercept = 0,
    color = "red",
    linetype = "dashed",
    linewidth = 1
  )



```



```{r}
library(vidger)
hl <- c("AT1G02920",
        "AT1G02930", 
  "AT1G05340", "AT1G08310" , "AT1G09080", "AT1G09932",
"AT1G14870", "AT1G15010", "AT1G21400", "AT1G34420", "AT1G56060", "AT1G65240", "AT1G65845" , "AT1G70170", "AT1G73260", "AT1G73810" , "AT1G78190", "AT2G27389", "AT2G28710",
"AT2G38870", "AT2G39518", "AT2G41905", "AT3G02040", "AT3G11080", "AT3G48630", "AT3G50470", "AT3G49780", "AT3G52400", "AT3G57380", "AT3G61390", "AT4G08780", "AT4G11910", "AT4G12480", "AT4G12490", "AT4G14630", "AT4G15270", "AT4G15610", "AT4G31800", "AT4G34380", "AT5G08380", "AT5G13190", "AT5G18470", "AT5G20230", "AT5G24530", "AT5G26920", "AT5G42300", "AT5G50200", "AT5G54140", "AT5G55470", "AT5G55560", "AT5G56970", "AT5G57010","AT5G64120"
)
library(ggrepel)

FW_df <- vsFourWay(
  x = "H", y = "IM",
  control = "UM",
  data = results_object,
  d.factor = "Groups",
  type = "deseq",
  padj = 0.05, lfc = 1,
  highlight = hl,
  title = TRUE, grid = TRUE, legend = TRUE,
  data.return = TRUE
)

FW_df

```

